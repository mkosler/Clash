<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/flash/_std/EReg.hx">
		<r><c path="flash.utils.RegExp"/></r>
		<result><c path="+Array"/></result>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="40">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="44">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="57">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="62">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="69">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="73">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx" extern="1"><haxe_doc>
	An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/flash/_std/Hash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/flash/_std/IntHash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable] having [pred] returning true.
	</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.
	</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>
		Returns a list containing all items of 'a' followed by all items of 'b'
	</haxe_doc>
		</concat>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><c path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<blendShader public="1" get="null"><c path="flash.display.Shader"/></blendShader>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<height public="1"><c path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><c path="Float"/></rotation>
		<rotationX public="1"><c path="Float"/></rotationX>
		<rotationY public="1"><c path="Float"/></rotationY>
		<rotationZ public="1"><c path="Float"/></rotationZ>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleZ public="1"><c path="Float"/></scaleZ>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><e path="Bool"/></visible>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<z public="1"><c path="Float"/></z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Vector3D"/>
</f></globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<local3DToGlobal public="1" set="method"><f a="point3d">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Point"/>
</f></local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<needsSoftKeyboard public="1"><e path="Bool"/></needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1"><c path="flash.geom.Rectangle"/></softKeyboardInputAreaOfInterest>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<requestSoftKeyboard public="1"><f a=""><e path="Bool"/></f></requestSoftKeyboard>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></removeChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<startTouchDrag public="1"><f a="touchPointID:?lockCenter:?bounds">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<stopTouchDrag public="1"><f a="touchPointID">
	<c path="Int"/>
	<e path="Void"/>
</f></stopTouchDrag>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.haxepunk.Engine" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Engine.hx">
		<extends path="flash.display.Sprite"/>
		<paused public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the game should stop updating/rendering.
	 </haxe_doc>
		</paused>
		<maxElapsed public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Cap on the elapsed time (default at 30 FPS). Raise this to allow for lower framerates (eg. 1 / 10).
	 </haxe_doc>
		</maxElapsed>
		<maxFrameSkip public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The max amount of frames that can be skipped in fixed framerate mode.
	 </haxe_doc>
		</maxFrameSkip>
		<tickRate public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The amount of milliseconds between ticks in fixed framerate mode.
	 </haxe_doc>
		</tickRate>
		<init public="1" set="method" line="90">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called after Engine has been added to the stage.
	 </haxe_doc>
		</init>
		<focusGained public="1" set="method" line="95">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called when game gains focus
	 </haxe_doc>
		</focusGained>
		<focusLost public="1" set="method" line="100">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called when game loses focus
	 </haxe_doc>
		</focusLost>
		<update public="1" set="method" line="105">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates the game, updating the World and Entities.
	 </haxe_doc>
		</update>
		<render public="1" set="method" line="121">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Renders the game, rendering the World and Entities.
	 </haxe_doc>
		</render>
		<setStageProperties public="1" set="method" line="145">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Sets the game's stage properties. Override this to set them differently.
	 </haxe_doc>
		</setStageProperties>
		<resize set="method" line="172">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Event handler for stage resize </haxe_doc>
		</resize>
		<onStage set="method" line="178">
			<f a="?e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Event handler for stage entry. </haxe_doc>
		</onStage>
		<onEnterFrame set="method" line="220">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Framerate independent game loop. </haxe_doc>
		</onEnterFrame>
		<onTimer set="method" line="254">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Fixed framerate game loop. </haxe_doc>
		</onTimer>
		<checkWorld set="method" line="306">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Switch Worlds if they've changed. </haxe_doc>
		</checkWorld>
		<_delta><c path="Float"/></_delta>
		<_time><c path="Float"/></_time>
		<_last><c path="Float"/></_last>
		<_timer><c path="haxe.Timer"/></_timer>
		<_rate><c path="Float"/></_rate>
		<_skip><c path="Float"/></_skip>
		<_prev><c path="Float"/></_prev>
		<_updateTime><c path="Float"/></_updateTime>
		<_renderTime><c path="Float"/></_renderTime>
		<_gameTime><c path="Float"/></_gameTime>
		<_flashTime><c path="Float"/></_flashTime>
		<_frameLast><c path="Float"/></_frameLast>
		<_frameListSum><c path="Int"/></_frameListSum>
		<_frameList><c path="Array"><c path="Int"/></c></_frameList>
		<new public="1" set="method" line="50">
			<f a="width:height:?frameRate:?fixed">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor. Defines startup information about your game.
	 * @param	width			The width of your game.
	 * @param	height			The height of your game.
	 * @param	frameRate		The game framerate, in frames per second.
	 * @param	fixed			If a fixed-framerate should be used.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Main game Sprite class, added to the Flash Stage. Manages the game loop.
 </haxe_doc>
	</class>
	<class path="Main" params="" file="src/Main.hx">
		<extends path="com.haxepunk.Engine"/>
		<kScreenWidth public="1" get="inline" set="null" line="9" static="1"><c path="Int"/></kScreenWidth>
		<kScreenHeight public="1" get="inline" set="null" line="10" static="1"><c path="Int"/></kScreenHeight>
		<kFrameRate public="1" get="inline" set="null" line="11" static="1"><c path="Int"/></kFrameRate>
		<kClearColor public="1" get="inline" set="null" line="12" static="1"><c path="Int"/></kClearColor>
		<kProjectName public="1" get="inline" set="null" line="13" static="1"><c path="String"/></kProjectName>
		<main public="1" set="method" line="35" static="1"><f a=""><e path="Void"/></f></main>
		<init public="1" set="method" line="20" override="1"><f a=""><e path="Void"/></f></init>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Similar to field but also supports property (might be slower).
	</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Similar to setField but also supports property (might be slower).
	</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>
	The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.
</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="com.haxepunk.Tweener" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Tweener.hx">
		<active public="1"><e path="Bool"/></active>
		<autoClear public="1"><e path="Bool"/></autoClear>
		<update public="1" set="method" line="16"><f a=""><e path="Void"/></f></update>
		<addTween public="1" set="method" line="21"><f a="t:?start">
	<c path="com.haxepunk.Tween"/>
	<e path="Bool"/>
	<c path="com.haxepunk.Tween"/>
</f></addTween>
		<removeTween public="1" set="method" line="34"><f a="t">
	<c path="com.haxepunk.Tween"/>
	<c path="com.haxepunk.Tween"/>
</f></removeTween>
		<clearTweens public="1" set="method" line="54"><f a=""><e path="Void"/></f></clearTweens>
		<updateTweens public="1" set="method" line="67"><f a=""><e path="Void"/></f></updateTweens>
		<hasTween public="1" get="getTween" set="null"><e path="Bool"/></hasTween>
		<getTween set="method" line="84"><f a=""><e path="Bool"/></f></getTween>
		<_tween><c path="com.haxepunk.Tween"/></_tween>
		<new public="1" set="method" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.haxepunk.World" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/World.hx">
		<extends path="com.haxepunk.Tweener"/>
		<squareRects set="method" line="1201" static="1">
			<f a="x1:y1:w1:h1:x2:y2:w2:h2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> @private Calculates the squared distance between two rectangles. </haxe_doc>
		</squareRects>
		<squarePoints set="method" line="1224" static="1">
			<f a="x1:y1:x2:y2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> @private Calculates the squared distance between two points. </haxe_doc>
		</squarePoints>
		<squarePointRect set="method" line="1230" static="1">
			<f a="px:py:rx:ry:rw:rh">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> @private Calculates the squared distance between a rectangle and a point. </haxe_doc>
		</squarePointRect>
		<visible public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the render() loop is performed.
	 </haxe_doc>
		</visible>
		<camera public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * Point used to determine drawing offset in the render loop.
	 </haxe_doc>
		</camera>
		<begin public="1" set="method" line="51">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this; called when World is switch to, and set to the currently active world.
	 </haxe_doc>
		</begin>
		<end public="1" set="method" line="56">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this; called when World is changed, and the active world is no longer this.
	 </haxe_doc>
		</end>
		<focusGained public="1" set="method" line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called when game gains focus
	 </haxe_doc>
		</focusGained>
		<focusLost public="1" set="method" line="66">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called when game loses focus
	 </haxe_doc>
		</focusLost>
		<update public="1" set="method" line="73" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Performed by the game loop, updates all contained Entities.
	 * If you override this to give your World update code, remember
	 * to call super.update() or your Entities will not be updated.
	 </haxe_doc>
		</update>
		<render public="1" set="method" line="96">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Performed by the game loop, renders all contained Entities.
	 * If you override this to give your World render code, remember
	 * to call super.render() or your Entities will not be rendered.
	 </haxe_doc>
		</render>
		<mouseX public="1" get="getMouseX" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * X position of the mouse in the World.
	 </haxe_doc>
		</mouseX>
		<getMouseX get="inline" set="null" line="131"><f a=""><c path="Int"/></f></getMouseX>
		<mouseY public="1" get="getMouseY" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Y position of the mouse in the world.
	 </haxe_doc>
		</mouseY>
		<getMouseY get="inline" set="null" line="140"><f a=""><c path="Int"/></f></getMouseY>
		<add public="1" set="method" line="150">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Adds the Entity to the World at the end of the frame.
	 * @param	e		Entity object you want to add.
	 * @return	The added Entity object.
	 </haxe_doc>
		</add>
		<remove public="1" set="method" line="164">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Removes the Entity from the World at the end of the frame.
	 * @param	e		Entity object you want to remove.
	 * @return	The removed Entity object.
	 </haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="176">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes all Entities from the World at the end of the frame.
	 </haxe_doc>
		</removeAll>
		<addList public="1" set="method" line="193">
			<f a="list">
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adds multiple Entities to the world.
	 * @param	...list		Several Entities (as arguments) or an Array/Vector of Entities.
	 </haxe_doc>
		</addList>
		<removeList public="1" set="method" line="203">
			<f a="list">
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes multiple Entities from the world.
	 * @param	...list		Several Entities (as arguments) or an Array/Vector of Entities.
	 </haxe_doc>
		</removeList>
		<addGraphic public="1" set="method" line="217">
			<f a="graphic:?layer:?x:?y">
				<c path="com.haxepunk.Graphic"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Adds an Entity to the World with the Graphic object.
	 * @param	graphic		Graphic to assign the Entity.
	 * @param	x			X position of the Entity.
	 * @param	y			Y position of the Entity.
	 * @param	layer		Layer of the Entity.
	 * @return	The Entity that was added.
	 </haxe_doc>
		</addGraphic>
		<addMask public="1" set="method" line="233">
			<f a="mask:type:?x:?y">
				<c path="com.haxepunk.Mask"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Adds an Entity to the World with the Mask object.
	 * @param	mask	Mask to assign the Entity.
	 * @param	type	Collision type of the Entity.
	 * @param	x		X position of the Entity.
	 * @param	y		Y position of the Entity.
	 * @return	The Entity that was added.
	 </haxe_doc>
		</addMask>
		<create public="1" set="method" line="247">
			<f a="classType:?addToWorld">
				<c path="Class"><d/></c>
				<e path="Bool"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Returns a new Entity, or a stored recycled Entity if one exists.
	 * @param	classType		The Class of the Entity you want to add.
	 * @param	addToWorld		Add it to the World immediately.
	 * @return	The new Entity object.
	 </haxe_doc>
		</create>
		<recycle public="1" set="method" line="268">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Removes the Entity from the World at the end of the frame and recycles it.
	 * The recycled Entity can then be fetched again by calling the create() function.
	 * @param	e		The Entity to recycle.
	 * @return	The recycled Entity.
	 </haxe_doc>
		</recycle>
		<clearRecycled public="1" set="method" line="281">
			<f a="classType">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Clears stored reycled Entities of the Class type.
	 * @param	classType		The Class type to clear.
	 </haxe_doc>
		</clearRecycled>
		<clearRecycledAll public="1" set="method" line="299">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Clears stored recycled Entities of all Class types.
	 </haxe_doc>
		</clearRecycledAll>
		<bringToFront public="1" set="method" line="315">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Brings the Entity to the front of its contained layer.
	 * @param	e		The Entity to shift.
	 * @return	If the Entity changed position.
	 </haxe_doc>
		</bringToFront>
		<sendToBack public="1" set="method" line="336">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Sends the Entity to the back of its contained layer.
	 * @param	e		The Entity to shift.
	 * @return	If the Entity changed position.
	 </haxe_doc>
		</sendToBack>
		<bringForward public="1" set="method" line="357">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Shifts the Entity one place towards the front of its contained layer.
	 * @param	e		The Entity to shift.
	 * @return	If the Entity changed position.
	 </haxe_doc>
		</bringForward>
		<sendBackward public="1" set="method" line="379">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Shifts the Entity one place towards the back of its contained layer.
	 * @param	e		The Entity to shift.
	 * @return	If the Entity changed position.
	 </haxe_doc>
		</sendBackward>
		<isAtFront public="1" get="inline" set="null" line="401">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * If the Entity as at the front of its layer.
	 * @param	e		The Entity to check.
	 * @return	True or false.
	 </haxe_doc>
		</isAtFront>
		<isAtBack public="1" get="inline" set="null" line="412">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * If the Entity as at the back of its layer.
	 * @param	e		The Entity to check.
	 * @return	True or false.
	 </haxe_doc>
		</isAtBack>
		<collideRect public="1" set="method" line="427">
			<f a="type:rX:rY:rWidth:rHeight">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Returns the first Entity that collides with the rectangular area.
	 * @param	type		The Entity type to check for.
	 * @param	rX			X position of the rectangle.
	 * @param	rY			Y position of the rectangle.
	 * @param	rWidth		Width of the rectangle.
	 * @param	rHeight		Height of the rectangle.
	 * @return	The first Entity to collide, or null if none collide.
	 </haxe_doc>
		</collideRect>
		<collidePoint public="1" set="method" line="447">
			<f a="type:pX:pY">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Returns the first Entity found that collides with the position.
	 * @param	type		The Entity type to check for.
	 * @param	pX			X position.
	 * @param	pY			Y position.
	 * @return	The collided Entity, or null if none collide.
	 </haxe_doc>
		</collidePoint>
		<collideLine public="1" set="method" line="472">
			<f a="type:fromX:fromY:toX:toY:?precision:?p">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.geom.Point"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Returns the first Entity found that collides with the line.
	 * @param	type		The Entity type to check for.
	 * @param	fromX		Start x of the line.
	 * @param	fromY		Start y of the line.
	 * @param	toX			End x of the line.
	 * @param	toY			End y of the line.
	 * @param	precision
	 * @param	p
	 * @return
	 </haxe_doc>
		</collideLine>
		<collideRectInto public="1" set="method" line="601">
			<f a="type:rX:rY:rWidth:rHeight:into">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Populates an array with all Entities that collide with the rectangle. This
	 * function does not empty the array, that responsibility is left to the user.
	 * @param	type		The Entity type to check for.
	 * @param	rX			X position of the rectangle.
	 * @param	rY			Y position of the rectangle.
	 * @param	rWidth		Width of the rectangle.
	 * @param	rHeight		Height of the rectangle.
	 * @param	into		The Array or Vector to populate with collided Entities.
	 </haxe_doc>
		</collideRectInto>
		<collideCircleInto public="1" set="method" line="623">
			<f a="type:circleX:circleY:radius:into">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Populates an array with all Entities that collide with the circle. This
	 * function does not empty the array, that responsibility is left to the user.
	 * @param	type 		The Entity type to check for.
	 * @param	circleX		X position of the circle.
	 * @param	circleY		Y position of the circle.
	 * @param	radius		The radius of the circle.
	 * @param	into		The Array or Vector to populate with collided Entities.
	 </haxe_doc>
		</collideCircleInto>
		<collidePointInto public="1" set="method" line="647">
			<f a="type:pX:pY:into">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Populates an array with all Entities that collide with the position. This
	 * function does not empty the array, that responsibility is left to the user.
	 * @param	type		The Entity type to check for.
	 * @param	pX			X position.
	 * @param	pY			Y position.
	 * @param	into		The Array or Vector to populate with collided Entities.
	 * @return	The provided Array.
	 </haxe_doc>
		</collidePointInto>
		<nearestToRect public="1" set="method" line="669">
			<f a="type:x:y:width:height">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Finds the Entity nearest to the rectangle.
	 * @param	type		The Entity type to check for.
	 * @param	x			X position of the rectangle.
	 * @param	y			Y position of the rectangle.
	 * @param	width		Width of the rectangle.
	 * @param	height		Height of the rectangle.
	 * @return	The nearest Entity to the rectangle.
	 </haxe_doc>
		</nearestToRect>
		<nearestToEntity public="1" set="method" line="696">
			<f a="type:e:?useHitboxes">
				<c path="String"/>
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Finds the Entity nearest to another.
	 * @param	type		The Entity type to check for.
	 * @param	e			The Entity to find the nearest to.
	 * @param	useHitboxes	If the Entities' hitboxes should be used to determine the distance. If false, their x/y coordinates are used.
	 * @return	The nearest Entity to e.
	 </haxe_doc>
		</nearestToEntity>
		<nearestToClass public="1" set="method" line="728">
			<f a="type:e:classType:?useHitboxes">
				<c path="String"/>
				<c path="com.haxepunk.Entity"/>
				<d/>
				<e path="Bool"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Finds the Entity nearest to another.
	 * @param	type		The Entity type to check for.
	 * @param	e			The Entity to find the nearest to.
	 * @param	useHitboxes	If the Entities' hitboxes should be used to determine the distance. If false, their x/y coordinates are used.
	 * @return	The nearest Entity to e.
	 </haxe_doc>
		</nearestToClass>
		<nearestToPoint public="1" set="method" line="760">
			<f a="type:x:y:?useHitboxes">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Finds the Entity nearest to the position.
	 * @param	type		The Entity type to check for.
	 * @param	x			X position.
	 * @param	y			Y position.
	 * @param	useHitboxes	If the Entities' hitboxes should be used to determine the distance. If false, their x/y coordinates are used.
	 * @return	The nearest Entity to the position.
	 </haxe_doc>
		</nearestToPoint>
		<count public="1" get="getCount" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * How many Entities are in the World.
	 </haxe_doc>
		</count>
		<getCount get="inline" set="null" line="800"><f a=""><c path="Int"/></f></getCount>
		<typeCount public="1" get="inline" set="null" line="807">
			<f a="type">
				<c path="String"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Returns the amount of Entities of the type are in the World.
	 * @param	type		The type (or Class type) to count.
	 * @return	How many Entities of type exist in the World.
	 </haxe_doc>
		</typeCount>
		<classCount public="1" get="inline" set="null" line="817">
			<f a="c">
				<c path="String"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Returns the amount of Entities of the Class are in the World.
	 * @param	c		The Class type to count.
	 * @return	How many Entities of Class exist in the World.
	 </haxe_doc>
		</classCount>
		<layerCount public="1" get="inline" set="null" line="827">
			<f a="layer">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Returns the amount of Entities are on the layer in the World.
	 * @param	layer		The layer to count Entities on.
	 * @return	How many Entities are on the layer.
	 </haxe_doc>
		</layerCount>
		<first public="1" get="getFirst" set="null">
			<c path="com.haxepunk.Entity"/>
			<haxe_doc>
	 * The first Entity in the World.
	 </haxe_doc>
		</first>
		<getFirst get="inline" set="null" line="836"><f a=""><c path="com.haxepunk.Entity"/></f></getFirst>
		<layers public="1" get="getLayers" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * How many Entity layers the World has.
	 </haxe_doc>
		</layers>
		<getLayers get="inline" set="null" line="842"><f a=""><c path="Int"/></f></getLayers>
		<typeFirst public="1" set="method" line="849">
			<f a="type">
				<c path="String"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * The first Entity of the type.
	 * @param	type		The type to check.
	 * @return	The Entity.
	 </haxe_doc>
		</typeFirst>
		<layerFirst public="1" set="method" line="879">
			<f a="layer">
				<c path="Int"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * The first Entity on the Layer.
	 * @param	layer		The layer to check.
	 * @return	The Entity.
	 </haxe_doc>
		</layerFirst>
		<layerLast public="1" set="method" line="890">
			<f a="layer">
				<c path="Int"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * The last Entity on the Layer.
	 * @param	layer		The layer to check.
	 * @return	The Entity.
	 </haxe_doc>
		</layerLast>
		<farthest public="1" get="getFarthest" set="null">
			<c path="com.haxepunk.Entity"/>
			<haxe_doc>
	 * The Entity that will be rendered first by the World.
	 </haxe_doc>
		</farthest>
		<getFarthest set="method" line="900"><f a=""><c path="com.haxepunk.Entity"/></f></getFarthest>
		<nearest public="1" get="getNearest" set="null">
			<c path="com.haxepunk.Entity"/>
			<haxe_doc>
	 * The Entity that will be rendered last by the world.
	 </haxe_doc>
		</nearest>
		<getNearest set="method" line="910"><f a=""><c path="com.haxepunk.Entity"/></f></getNearest>
		<layerFarthest public="1" get="getLayerFarthest" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The layer that will be rendered first by the World.
	 </haxe_doc>
		</layerFarthest>
		<getLayerFarthest set="method" line="920"><f a=""><c path="Int"/></f></getLayerFarthest>
		<layerNearest public="1" get="getLayerNearest" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The layer that will be rendered last by the World.
	 </haxe_doc>
		</layerNearest>
		<getLayerNearest set="method" line="930"><f a=""><c path="Int"/></f></getLayerNearest>
		<uniqueTypes public="1" get="getUniqueTypes" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * How many different types have been added to the World.
	 </haxe_doc>
		</uniqueTypes>
		<getUniqueTypes get="inline" set="null" line="940"><f a=""><c path="Int"/></f></getUniqueTypes>
		<getType public="1" set="method" line="954">
			<f a="type:into">
				<c path="String"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pushes all Entities in the World of the type into the Array or Vector.
	 * @param	type		The type to check.
	 * @param	into		The Array or Vector to populate.
	 * @return	The same array, populated.
	 </haxe_doc>
		</getType>
		<getClass public="1" set="method" line="973">
			<f a="c:into">
				<c path="Class"><d/></c>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pushes all Entities in the World of the Class into the Array or Vector.
	 * @param	c			The Class type to check.
	 * @param	into		The Array or Vector to populate.
	 * @return	The same array, populated.
	 </haxe_doc>
		</getClass>
		<getLayer public="1" set="method" line="991">
			<f a="layer:into">
				<c path="Int"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pushes all Entities in the World on the layer into the Array or Vector.
	 * @param	layer		The layer to check.
	 * @param	into		The Array or Vector to populate.
	 * @return	The same array, populated.
	 </haxe_doc>
		</getLayer>
		<getAll public="1" set="method" line="1009">
			<f a="into">
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pushes all Entities in the World into the array.
	 * @param	into		The Array or Vector to populate.
	 * @return	The same array, populated.
	 </haxe_doc>
		</getAll>
		<updateLists public="1" set="method" line="1025">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates the add/remove lists at the end of the frame.
	 </haxe_doc>
		</updateLists>
		<layerSort set="method" line="1074"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></layerSort>
		<addUpdate set="method" line="1085">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Adds Entity to the update list. </haxe_doc>
		</addUpdate>
		<removeUpdate set="method" line="1104">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Removes Entity from the update list. </haxe_doc>
		</removeUpdate>
		<addRender public="1" set="method" line="1118">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Adds Entity to the render list. </haxe_doc>
		</addRender>
		<removeRender public="1" set="method" line="1143">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Removes Entity from the render list. </haxe_doc>
		</removeRender>
		<addType public="1" set="method" line="1169">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Adds Entity to the type list. </haxe_doc>
		</addType>
		<removeType public="1" set="method" line="1189">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Removes Entity from the type list. </haxe_doc>
		</removeType>
		<_add><c path="Array"><c path="com.haxepunk.Entity"/></c></_add>
		<_remove><c path="Array"><c path="com.haxepunk.Entity"/></c></_remove>
		<_updateFirst><t path="com.haxepunk.FriendEntity"/></_updateFirst>
		<_count><c path="Int"/></_count>
		<_renderFirst><c path="Array"><t path="com.haxepunk.FriendEntity"/></c></_renderFirst>
		<_renderLast><c path="Array"><t path="com.haxepunk.FriendEntity"/></c></_renderLast>
		<_layerList><c path="Array"><c path="Int"/></c></_layerList>
		<_layerCount><c path="Array"><c path="Int"/></c></_layerCount>
		<_layerSort><e path="Bool"/></_layerSort>
		<_tempArray><c path="Array"><c path="com.haxepunk.Entity"/></c></_tempArray>
		<_classCount><c path="Hash"><c path="Int"/></c></_classCount>
		<_typeFirst public="1"><c path="Hash"><t path="com.haxepunk.FriendEntity"/></c></_typeFirst>
		<_typeCount><c path="Hash"><c path="Int"/></c></_typeCount>
		<_recycled><c path="Hash"><c path="com.haxepunk.Entity"/></c></_recycled>
		<new public="1" set="method" line="27">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Updated by Engine, main game container that holds all currently active Entities.
 * Useful for organization, eg. "Menu", "Level1", etc.
 </haxe_doc>
	</class>
	<class path="Test" params="" file="src/Test.hx">
		<extends path="com.haxepunk.World"/>
		<_currentClash><c path="clash.data.Clash"/></_currentClash>
		<begin public="1" set="method" line="26" override="1"><f a=""><e path="Void"/></f></begin>
		<update public="1" set="method" line="43" override="1"><f a=""><e path="Void"/></f></update>
		<ButtonCallback set="method" line="59"><f a=""><e path="Void"/></f></ButtonCallback>
		<CheckboxCallback set="method" line="64"><f a=""><e path="Void"/></f></CheckboxCallback>
		<RadioCallback set="method" line="69"><f a="id">
	<c path="String"/>
	<e path="Void"/>
</f></RadioCallback>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="86" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="90" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="111" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="128" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="149" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="162" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="174" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="180" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="197" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="201" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="208" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="213" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="245" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="262" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="266" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="270" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="274" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>
		Returns the list of all enum values that don't take any parameter.
	</haxe_doc>
		</allEnums>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/flash/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="/usr/lib/haxe/std/flash/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" set="method" line="50" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="74" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="78" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="83" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="87" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="92" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="96" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="101" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<getNodeType set="method" line="105" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
</f></getNodeType>
		<wrap set="method" line="181" static="1"><f a="map:node:?type">
	<c path="flash.utils.Dictionary"/>
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
	<c path="Xml"/>
</f></wrap>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<_map><c path="flash.utils.Dictionary"/></_map>
		<_node><c path="flash.xml.XML"/></_node>
		<getNodeName set="method" line="121"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="128"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="141"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="150"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="177"><f a=""><c path="Xml"/></f></getParent>
		<wraps set="method" line="195"><f a="xList">
	<c path="flash.xml.XMLList"/>
	<c path="Array"><c path="Xml"/></c>
</f></wraps>
		<getAttribNS set="method" line="202"><f a="cur:ns">
	<c path="flash.xml.XML"/>
	<c path="Array"><c path="String"/></c>
	<c path="flash.xml.XMLList"/>
</f></getAttribNS>
		<get public="1" set="method" line="215">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method" line="232">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method" line="253">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method" line="263">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="274">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="290">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="306">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="322">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="347">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="356">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="365">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="372">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="383">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<new set="method" line="72"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="com.haxepunk.Entity" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Entity.hx">
		<extends path="com.haxepunk.Tweener"/>
		<visible public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the Entity should render.
	 </haxe_doc>
		</visible>
		<collidable public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the Entity should respond to collision checks.
	 </haxe_doc>
		</collidable>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>
	 * X position of the Entity in the World.
	 </haxe_doc>
		</x>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Y position of the Entity in the World.
	 </haxe_doc>
		</y>
		<width public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Width of the Entity's hitbox.
	 </haxe_doc>
		</width>
		<height public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Height of the Entity's hitbox.
	 </haxe_doc>
		</height>
		<originX public="1">
			<c path="Int"/>
			<haxe_doc>
	 * X origin of the Entity's hitbox.
	 </haxe_doc>
		</originX>
		<originY public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Y origin of the Entity's hitbox.
	 </haxe_doc>
		</originY>
		<renderTarget public="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>
	 * The BitmapData target to draw the Entity to. Leave as null to render to the current screen buffer (default).
	 </haxe_doc>
		</renderTarget>
		<added public="1" set="method" line="114">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called when the Entity is added to a World.
	 </haxe_doc>
		</added>
		<removed public="1" set="method" line="122">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this, called when the Entity is removed from a World.
	 </haxe_doc>
		</removed>
		<update public="1" set="method" line="130" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates the Entity.
	 </haxe_doc>
		</update>
		<render public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Renders the Entity. If you override this for special behaviour,
	 * remember to call super.render() to render the Entity's graphic.
	 </haxe_doc>
		</render>
		<collide public="1" set="method" line="162">
			<f a="type:x:y">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Checks for a collision against an Entity type.
	 * @param	type		The Entity type to check for.
	 * @param	x			Virtual x position to place this Entity.
	 * @param	y			Virtual y position to place this Entity.
	 * @return	The first Entity collided with, or null if none were collided.
	 </haxe_doc>
		</collide>
		<collideTypes public="1" set="method" line="224">
			<f a="types:x:y">
				<d/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Checks for collision against multiple Entity types.
	 * @param	types		An Array or Vector of Entity types to check for.
	 * @param	x			Virtual x position to place this Entity.
	 * @param	y			Virtual y position to place this Entity.
	 * @return	The first Entity collided with, or null if none were collided.
	 </haxe_doc>
		</collideTypes>
		<collideWith public="1" set="method" line="257">
			<f a="e:x:y">
				<c path="com.haxepunk.Entity"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Entity"/>
			</f>
			<haxe_doc>
	 * Checks if this Entity collides with a specific Entity.
	 * @param	e		The Entity to collide against.
	 * @param	x		Virtual x position to place this Entity.
	 * @param	y		Virtual y position to place this Entity.
	 * @return	The Entity if they overlap, or null if they don't.
	 </haxe_doc>
		</collideWith>
		<collideRect public="1" set="method" line="298">
			<f a="x:y:rX:rY:rWidth:rHeight">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Checks if this Entity overlaps the specified rectangle.
	 * @param	x			Virtual x position to place this Entity.
	 * @param	y			Virtual y position to place this Entity.
	 * @param	rX			X position of the rectangle.
	 * @param	rY			Y position of the rectangle.
	 * @param	rWidth		Width of the rectangle.
	 * @param	rHeight		Height of the rectangle.
	 * @return	If they overlap.
	 </haxe_doc>
		</collideRect>
		<collidePoint public="1" set="method" line="329">
			<f a="x:y:pX:pY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Checks if this Entity overlaps the specified position.
	 * @param	x			Virtual x position to place this Entity.
	 * @param	y			Virtual y position to place this Entity.
	 * @param	pX			X position.
	 * @param	pY			Y position.
	 * @return	If the Entity intersects with the position.
	 </haxe_doc>
		</collidePoint>
		<collideInto public="1" set="method" line="360">
			<f a="type:x:y:array">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Populates an array with all collided Entities of a type.
	 * @param	type		The Entity type to check for.
	 * @param	x			Virtual x position to place this Entity.
	 * @param	y			Virtual y position to place this Entity.
	 * @param	array		The Array or Vector object to populate.
	 * @return	The array, populated with all collided Entities.
	 </haxe_doc>
		</collideInto>
		<collideTypesInto public="1" set="method" line="416">
			<f a="types:x:y:array">
				<c path="Array"><c path="String"/></c>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Array"><c path="com.haxepunk.Entity"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Populates an array with all collided Entities of multiple types.
	 * @param	types		An array of Entity types to check for.
	 * @param	x			Virtual x position to place this Entity.
	 * @param	y			Virtual y position to place this Entity.
	 * @param	array		The Array or Vector object to populate.
	 * @return	The array, populated with all collided Entities.
	 </haxe_doc>
		</collideTypesInto>
		<onCamera public="1" get="getOnCamera" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * If the Entity collides with the camera rectangle.
	 </haxe_doc>
		</onCamera>
		<getOnCamera get="inline" set="null" line="427"><f a=""><e path="Bool"/></f></getOnCamera>
		<world public="1" get="getWorld" set="null">
			<c path="com.haxepunk.World"/>
			<haxe_doc>
	 * The World object this Entity has been added to.
	 </haxe_doc>
		</world>
		<getWorld get="inline" set="null" line="436"><f a=""><c path="com.haxepunk.World"/></f></getWorld>
		<halfWidth public="1" get="getHalfWidth" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * Half the Entity's width.
	 </haxe_doc>
		</halfWidth>
		<getHalfWidth get="inline" set="null" line="445"><f a=""><c path="Float"/></f></getHalfWidth>
		<halfHeight public="1" get="getHalfHeight" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * Half the Entity's height.
	 </haxe_doc>
		</halfHeight>
		<getHalfHeight get="inline" set="null" line="451"><f a=""><c path="Float"/></f></getHalfHeight>
		<centerX public="1" get="getCenterX" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The center x position of the Entity's hitbox.
	 </haxe_doc>
		</centerX>
		<getCenterX get="inline" set="null" line="457"><f a=""><c path="Float"/></f></getCenterX>
		<centerY public="1" get="getCenterY" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The center y position of the Entity's hitbox.
	 </haxe_doc>
		</centerY>
		<getCenterY get="inline" set="null" line="463"><f a=""><c path="Float"/></f></getCenterY>
		<left public="1" get="getLeft" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The leftmost position of the Entity's hitbox.
	 </haxe_doc>
		</left>
		<getLeft get="inline" set="null" line="469"><f a=""><c path="Float"/></f></getLeft>
		<right public="1" get="getRight" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The rightmost position of the Entity's hitbox.
	 </haxe_doc>
		</right>
		<getRight get="inline" set="null" line="475"><f a=""><c path="Float"/></f></getRight>
		<top public="1" get="getTop" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The topmost position of the Entity's hitbox.
	 </haxe_doc>
		</top>
		<getTop get="inline" set="null" line="481"><f a=""><c path="Float"/></f></getTop>
		<bottom public="1" get="getBottom" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The bottommost position of the Entity's hitbox.
	 </haxe_doc>
		</bottom>
		<getBottom get="inline" set="null" line="487"><f a=""><c path="Float"/></f></getBottom>
		<layer public="1" get="getLayer" set="setLayer">
			<c path="Int"/>
			<haxe_doc>
	 * The rendering layer of this Entity. Higher layers are rendered first.
	 </haxe_doc>
		</layer>
		<getLayer get="inline" set="null" line="493"><f a=""><c path="Int"/></f></getLayer>
		<setLayer set="method" line="494"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setLayer>
		<type public="1" get="getType" set="setType">
			<c path="String"/>
			<haxe_doc>
	 * The collision type, used for collision checking.
	 </haxe_doc>
		</type>
		<getType get="inline" set="null" line="518"><f a=""><c path="String"/></f></getType>
		<setType set="method" line="519"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></setType>
		<mask public="1" get="getMask" set="setMask">
			<c path="com.haxepunk.Mask"/>
			<haxe_doc>
	 * An optional Mask component, used for specialized collision. If this is
	 * not assigned, collision checks will use the Entity's hitbox by default.
	 </haxe_doc>
		</mask>
		<getMask get="inline" set="null" line="538"><f a=""><c path="com.haxepunk.Mask"/></f></getMask>
		<setMask set="method" line="539"><f a="value">
	<c path="com.haxepunk.Mask"/>
	<c path="com.haxepunk.Mask"/>
</f></setMask>
		<graphic public="1" get="getGraphic" set="setGraphic">
			<c path="com.haxepunk.Graphic"/>
			<haxe_doc>
	 * Graphical component to render to the screen.
	 </haxe_doc>
		</graphic>
		<getGraphic get="inline" set="null" line="552"><f a=""><c path="com.haxepunk.Graphic"/></f></getGraphic>
		<setGraphic set="method" line="553"><f a="value">
	<c path="com.haxepunk.Graphic"/>
	<c path="com.haxepunk.Graphic"/>
</f></setGraphic>
		<addGraphic public="1" set="method" line="565">
			<f a="g">
				<c path="com.haxepunk.Graphic"/>
				<c path="com.haxepunk.Graphic"/>
			</f>
			<haxe_doc>
	 * Adds the graphic to the Entity via a Graphiclist.
	 * @param	g		Graphic to add.
	 </haxe_doc>
		</addGraphic>
		<setHitbox public="1" get="inline" set="null" line="584">
			<f a="?width:?height:?originX:?originY">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the Entity's hitbox properties.
	 * @param	width		Width of the hitbox.
	 * @param	height		Height of the hitbox.
	 * @param	originX		X origin of the hitbox.
	 * @param	originY		Y origin of the hitbox.
	 </haxe_doc>
		</setHitbox>
		<setHitboxTo public="1" set="method" line="596">
			<f a="o">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the Entity's hitbox to match that of the provided object.
	 * @param	o		The object defining the hitbox (eg. an Image or Rectangle).
	 </haxe_doc>
		</setHitboxTo>
		<setOrigin public="1" get="inline" set="null" line="621">
			<f a="?x:?y">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the origin of the Entity.
	 * @param	x		X origin.
	 * @param	y		Y origin.
	 </haxe_doc>
		</setOrigin>
		<centerOrigin public="1" get="inline" set="null" line="630">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Center's the Entity's origin (half width & height).
	 ]]></haxe_doc>
		</centerOrigin>
		<distanceFrom public="1" get="inline" set="null" line="642">
			<f a="e:?useHitboxes">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Calculates the distance from another Entity.
	 * @param	e				The other Entity.
	 * @param	useHitboxes		If hitboxes should be used to determine the distance. If not, the Entities' x/y positions are used.
	 * @return	The distance.
	 </haxe_doc>
		</distanceFrom>
		<distanceToPoint public="1" get="inline" set="null" line="655">
			<f a="px:py:?useHitbox">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Calculates the distance from this Entity to the point.
	 * @param	px				X position.
	 * @param	py				Y position.
	 * @param	useHitboxes		If hitboxes should be used to determine the distance. If not, the Entities' x/y positions are used.
	 * @return	The distance.
	 </haxe_doc>
		</distanceToPoint>
		<distanceToRect public="1" get="inline" set="null" line="669">
			<f a="rx:ry:rwidth:rheight">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Calculates the distance from this Entity to the rectangle.
	 * @param	rx			X position of the rectangle.
	 * @param	ry			Y position of the rectangle.
	 * @param	rwidth		Width of the rectangle.
	 * @param	rheight		Height of the rectangle.
	 * @return	The distance.
	 </haxe_doc>
		</distanceToRect>
		<toString public="1" set="method" line="678">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Gets the class name as a string.
	 * @return	A string representing the class name.
	 </haxe_doc>
		</toString>
		<moveBy public="1" set="method" line="690">
			<f a="x:y:?solidType:?sweep">
				<c path="Float"/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Moves the Entity by the amount, retaining integer values for its x and y.
	 * @param	x			Horizontal offset.
	 * @param	y			Vertical offset.
	 * @param	solidType	An optional collision type to stop flush against upon collision.
	 * @param	sweep		If sweeping should be used (prevents fast-moving objects from going through solidType).
	 </haxe_doc>
		</moveBy>
		<moveTo public="1" get="inline" set="null" line="758">
			<f a="x:y:?solidType:?sweep">
				<c path="Float"/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Moves the Entity to the position, retaining integer values for its x and y.
	 * @param	x			X position.
	 * @param	y			Y position.
	 * @param	solidType	An optional collision type to stop flush against upon collision.
	 * @param	sweep		If sweeping should be used (prevents fast-moving objects from going through solidType).
	 </haxe_doc>
		</moveTo>
		<moveTowards public="1" get="inline" set="null" line="771">
			<f a="x:y:amount:?solidType:?sweep">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Moves towards the target position, retaining integer values for its x and y.
	 * @param	x			X target.
	 * @param	y			Y target.
	 * @param	amount		Amount to move.
	 * @param	solidType	An optional collision type to stop flush against upon collision.
	 * @param	sweep		If sweeping should be used (prevents fast-moving objects from going through solidType).
	 </haxe_doc>
		</moveTowards>
		<moveCollideX public="1" set="method" line="783">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * When you collide with an Entity on the x-axis with moveTo() or moveBy().
	 * @param	e		The Entity you collided with.
	 </haxe_doc>
		</moveCollideX>
		<moveCollideY public="1" set="method" line="792">
			<f a="e">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * When you collide with an Entity on the y-axis with moveTo() or moveBy().
	 * @param	e		The Entity you collided with.
	 </haxe_doc>
		</moveCollideY>
		<clampHorizontal public="1" get="inline" set="null" line="803">
			<f a="left:right:?padding">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Clamps the Entity's hitbox on the x-axis.
	 * @param	left		Left bounds.
	 * @param	right		Right bounds.
	 * @param	padding		Optional padding on the clamp.
	 </haxe_doc>
		</clampHorizontal>
		<clampVertical public="1" get="inline" set="null" line="815">
			<f a="top:bottom:?padding">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Clamps the Entity's hitbox on the y axis.
	 * @param	top			Min bounds.
	 * @param	bottom		Max bounds.
	 * @param	padding		Optional padding on the clamp.
	 </haxe_doc>
		</clampVertical>
		<_class><c path="String"/></_class>
		<_world><c path="com.haxepunk.World"/></_world>
		<_added><e path="Bool"/></_added>
		<_type><c path="String"/></_type>
		<_layer><c path="Int"/></_layer>
		<_updatePrev><t path="com.haxepunk.FriendEntity"/></_updatePrev>
		<_updateNext><t path="com.haxepunk.FriendEntity"/></_updateNext>
		<_renderPrev><t path="com.haxepunk.FriendEntity"/></_renderPrev>
		<_renderNext><t path="com.haxepunk.FriendEntity"/></_renderNext>
		<_typePrev><t path="com.haxepunk.FriendEntity"/></_typePrev>
		<_typeNext><t path="com.haxepunk.FriendEntity"/></_typeNext>
		<_recycleNext><c path="com.haxepunk.Entity"/></_recycleNext>
		<HITBOX><c path="com.haxepunk.Mask"/></HITBOX>
		<_mask><c path="com.haxepunk.Mask"/></_mask>
		<_x><c path="Float"/></_x>
		<_y><c path="Float"/></_y>
		<_moveX><c path="Float"/></_moveX>
		<_moveY><c path="Float"/></_moveY>
		<_graphic><c path="com.haxepunk.Graphic"/></_graphic>
		<_point><c path="flash.geom.Point"/></_point>
		<_camera><c path="flash.geom.Point"/></_camera>
		<new public="1" set="method" line="86">
			<f a="?x:?y:?graphic:?mask">
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.Graphic"/>
				<c path="com.haxepunk.Mask"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor. Can be usd to place the Entity and assign a graphic and mask.
	 * @param	x			X position to place the Entity.
	 * @param	y			Y position to place the Entity.
	 * @param	graphic		Graphic to assign to the Entity.
	 * @param	mask		Mask to assign to the Entity.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Main game Entity class updated by World.
 </haxe_doc>
	</class>
	<class path="clash.ClashWidget" params="" file="src/clash/ClashWidget.hx">
		<extends path="com.haxepunk.Entity"/>
		<clash public="1"><c path="clash.data.Clash"/></clash>
		<removed public="1" set="method" line="30" override="1"><f a=""><e path="Void"/></f></removed>
		<reskin public="1" set="method" line="37"><f a="image">
	<c path="clash.data.ClashImage"/>
	<e path="Void"/>
</f></reskin>
		<makeSliceRectangle set="method" line="42"><f a="slice">
	<c path="clash.data.ClashSlice"/>
	<t path="nme.geom.Rectangle"/>
</f></makeSliceRectangle>
		<renderGraphic set="method" line="47"><f a="graphic">
	<c path="com.haxepunk.Graphic"/>
	<e path="Void"/>
</f></renderGraphic>
		<_style><c path="String"/></_style>
		<_clashIndex><c path="Int"/></_clashIndex>
		<_myPoint><t path="nme.geom.Point"/></_myPoint>
		<_myCamera><t path="nme.geom.Point"/></_myCamera>
		<new public="1" set="method" line="18"><f a="x:y:clash:?style">
	<c path="Float"/>
	<c path="Float"/>
	<c path="clash.data.Clash"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.Button" params="" file="src/clash/Button.hx">
		<extends path="clash.ClashWidget"/>
		<NORMAL get="inline" set="null" line="111" static="1"><c path="Int"/></NORMAL>
		<HOVER get="inline" set="null" line="114" static="1"><c path="Int"/></HOVER>
		<DOWN get="inline" set="null" line="117" static="1"><c path="Int"/></DOWN>
		<calling public="1"><f a=""><e path="Void"/></f></calling>
		<render public="1" set="method" line="46" override="1"><f a=""><e path="Void"/></f></render>
		<reskin public="1" set="method" line="53" override="1"><f a="image">
	<c path="clash.data.ClashImage"/>
	<e path="Void"/>
</f></reskin>
		<update public="1" set="method" line="60" override="1"><f a=""><e path="Void"/></f></update>
		<changeState set="method" line="91"><f a="?state">
	<c path="Int"/>
	<e path="Void"/>
</f></changeState>
		<click set="method" line="104"><f a=""><e path="Void"/></f></click>
		<_normal><c path="com.haxepunk.graphics.Image"/></_normal>
		<_normalRect><t path="nme.geom.Rectangle"/></_normalRect>
		<_hover><c path="com.haxepunk.graphics.Image"/></_hover>
		<_hoverRect><t path="nme.geom.Rectangle"/></_hoverRect>
		<_down><c path="com.haxepunk.graphics.Image"/></_down>
		<_downRect><t path="nme.geom.Rectangle"/></_downRect>
		<_label><c path="com.haxepunk.graphics.Text"/></_label>
		<_clicked><e path="Bool"/></_clicked>
		<new public="1" set="method" line="23"><f a="x:y:clash:?style:?text:?calling">
	<c path="Float"/>
	<c path="Float"/>
	<c path="clash.data.Clash"/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.Checkbox" params="" file="src/clash/Checkbox.hx">
		<extends path="clash.Button"/>
		<checked public="1"><e path="Bool"/></checked>
		<reskin public="1" set="method" line="42" override="1"><f a="image">
	<c path="clash.data.ClashImage"/>
	<e path="Void"/>
</f></reskin>
		<click set="method" line="51" override="1"><f a=""><e path="Void"/></f></click>
		<changeState set="method" line="58" override="1"><f a="?state">
	<c path="Int"/>
	<e path="Void"/>
</f></changeState>
		<_normalChecked><c path="com.haxepunk.graphics.Image"/></_normalChecked>
		<_normalCheckedRect><t path="nme.geom.Rectangle"/></_normalCheckedRect>
		<_hoverChecked><c path="com.haxepunk.graphics.Image"/></_hoverChecked>
		<_hoverCheckedRect><t path="nme.geom.Rectangle"/></_hoverCheckedRect>
		<_downChecked><c path="com.haxepunk.graphics.Image"/></_downChecked>
		<_downCheckedRect><t path="nme.geom.Rectangle"/></_downCheckedRect>
		<new public="1" set="method" line="16"><f a="x:y:clash:?style:?text:?calling">
	<c path="Float"/>
	<c path="Float"/>
	<c path="clash.data.Clash"/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.RadioButton" params="" file="src/clash/RadioButton.hx">
		<extends path="clash.Checkbox"/>
		<group public="1"><c path="clash.RadioGroup"/></group>
		<index public="1"><c path="Int"/></index>
		<id public="1"><c path="String"/></id>
		<removed public="1" set="method" line="43" override="1"><f a=""><e path="Void"/></f></removed>
		<click set="method" line="50" override="1"><f a=""><e path="Void"/></f></click>
		<new public="1" set="method" line="18"><f a="x:y:group:clash:?style:?text:?id">
	<c path="Float"/>
	<c path="Float"/>
	<c path="clash.RadioGroup"/>
	<c path="clash.data.Clash"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.RadioGroup" params="" file="src/clash/RadioButton.hx" module="clash.RadioButton">
		<calling public="1"><f a="">
	<c path="String"/>
	<e path="Void"/>
</f></calling>
		<add public="1" set="method" line="67"><f a="button">
	<c path="clash.RadioButton"/>
	<c path="clash.RadioButton"/>
</f></add>
		<addArray public="1" set="method" line="74"><f a="buttons">
	<c path="Array"><c path="clash.RadioButton"/></c>
	<e path="Void"/>
</f></addArray>
		<click public="1" set="method" line="81"><f a="target:id">
	<c path="clash.RadioButton"/>
	<c path="String"/>
	<e path="Void"/>
</f></click>
		<getAt public="1" set="method" line="93"><f a="index">
	<c path="Int"/>
	<c path="clash.RadioButton"/>
</f></getAt>
		<remove public="1" set="method" line="98"><f a="button">
	<c path="clash.RadioButton"/>
	<c path="clash.RadioButton"/>
</f></remove>
		<removeAll public="1" set="method" line="109"><f a=""><e path="Void"/></f></removeAll>
		<removeArray public="1" set="method" line="114"><f a="buttons">
	<c path="Array"><c path="clash.RadioButton"/></c>
	<e path="Void"/>
</f></removeArray>
		<_buttons><c path="Array"><c path="clash.RadioButton"/></c></_buttons>
		<new public="1" set="method" line="60"><f a="?buttons:?calling">
	<c path="Array"><c path="clash.RadioButton"/></c>
	<f a="">
		<c path="String"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.data.Clash" params="" file="src/clash/data/Clash.hx">
		<version public="1" set="null"><c path="String"/></version>
		<name public="1" set="null"><c path="String"/></name>
		<width public="1" set="null"><c path="Int"/></width>
		<height public="1" set="null"><c path="Int"/></height>
		<addWidget public="1" set="method" line="32"><f a="widget">
	<c path="clash.ClashWidget"/>
	<c path="Int"/>
</f></addWidget>
		<getCurrentImage public="1" set="method" line="37"><f a=""><c path="clash.data.ClashImage"/></f></getCurrentImage>
		<getElement public="1" set="method" line="42"><f a="name">
	<c path="String"/>
	<c path="clash.data.ClashElement"/>
</f></getElement>
		<getImage public="1" set="method" line="51"><f a="name">
	<c path="String"/>
	<c path="clash.data.ClashImage"/>
</f></getImage>
		<removeWidget public="1" set="method" line="60"><f a="index">
	<c path="Int"/>
	<e path="Void"/>
</f></removeWidget>
		<setCurrentImage public="1" set="method" line="65"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></setCurrentImage>
		<_images><c path="Hash"><c path="clash.data.ClashImage"/></c></_images>
		<_currentImage><c path="clash.data.ClashImage"/></_currentImage>
		<_elements><c path="Hash"><c path="clash.data.ClashElement"/></c></_elements>
		<_widgets><c path="Array"><c path="clash.ClashWidget"/></c></_widgets>
		<new public="1" set="method" line="12"><f a="version:name:width:height:images:elements:?currentImage">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="clash.data.ClashImage"/></c>
	<c path="Array"><c path="clash.data.ClashElement"/></c>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.data.ClashElement" params="" file="src/clash/data/ClashElement.hx">
		<name public="1" set="null"><c path="String"/></name>
		<getStyle public="1" set="method" line="16"><f a="name">
	<c path="String"/>
	<c path="clash.data.ClashStyle"/>
</f></getStyle>
		<toString public="1" set="method" line="25"><f a=""><c path="String"/></f></toString>
		<_styles><c path="Hash"><c path="clash.data.ClashStyle"/></c></_styles>
		<new public="1" set="method" line="7"><f a="name:styles">
	<c path="String"/>
	<c path="Array"><c path="clash.data.ClashStyle"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.data.ClashImage" params="" file="src/clash/data/ClashImage.hx">
		<name public="1" set="null"><c path="String"/></name>
		<path public="1" set="null"><c path="String"/></path>
		<toString public="1" set="method" line="14"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="name:path">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.data.ClashParser" params="" file="src/clash/data/ClashParser.hx">
		<parse public="1" set="method" line="13" static="1"><f a="path">
	<c path="String"/>
	<c path="clash.data.Clash"/>
</f></parse>
		<parseElements set="method" line="29" static="1"><f a="node">
	<c path="haxe.xml.Fast"/>
	<c path="Array"><c path="clash.data.ClashElement"/></c>
</f></parseElements>
		<parseImages set="method" line="41" static="1"><f a="node">
	<c path="haxe.xml.Fast"/>
	<c path="Array"><c path="clash.data.ClashImage"/></c>
</f></parseImages>
		<parseSlices set="method" line="50" static="1"><f a="node">
	<c path="haxe.xml.Fast"/>
	<c path="Array"><c path="clash.data.ClashSlice"/></c>
</f></parseSlices>
		<parseStyles set="method" line="79" static="1"><f a="node">
	<c path="haxe.xml.Fast"/>
	<c path="Array"><c path="clash.data.ClashStyle"/></c>
</f></parseStyles>
	</class>
	<class path="clash.data.ClashSlice" params="" file="src/clash/data/ClashSlice.hx">
		<name public="1" set="null"><c path="String"/></name>
		<x public="1" set="null"><c path="Float"/></x>
		<y public="1" set="null"><c path="Float"/></y>
		<width public="1" set="null"><c path="Int"/></width>
		<height public="1" set="null"><c path="Int"/></height>
		<checked public="1" set="null"><e path="Bool"/></checked>
		<toString public="1" set="method" line="22"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12"><f a="name:x:y:width:height:?checked">
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="clash.data.ClashStyle" params="" file="src/clash/data/ClashStyle.hx">
		<name public="1" set="null"><c path="String"/></name>
		<x public="1" set="null"><c path="Float"/></x>
		<y public="1" set="null"><c path="Float"/></y>
		<width public="1" set="null"><c path="Int"/></width>
		<height public="1" set="null"><c path="Int"/></height>
		<getSlice public="1" set="method" line="25"><f a="name:?checked">
	<c path="String"/>
	<e path="Bool"/>
	<c path="clash.data.ClashSlice"/>
</f></getSlice>
		<toString public="1" set="method" line="36"><f a=""><c path="String"/></f></toString>
		<_slices><c path="Hash"><c path="clash.data.ClashSlice"/></c></_slices>
		<new public="1" set="method" line="11"><f a="name:x:y:width:height:slices">
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="clash.data.ClashSlice"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="com.haxepunk.FriendEntity" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Entity.hx" module="com.haxepunk.Entity">
		<a>
			<_world><c path="com.haxepunk.World"/></_world>
			<_updatePrev><t path="com.haxepunk.FriendEntity"/></_updatePrev>
			<_updateNext><t path="com.haxepunk.FriendEntity"/></_updateNext>
			<_typePrev><t path="com.haxepunk.FriendEntity"/></_typePrev>
			<_typeNext><t path="com.haxepunk.FriendEntity"/></_typeNext>
			<_type><c path="String"/></_type>
			<_renderPrev><t path="com.haxepunk.FriendEntity"/></_renderPrev>
			<_renderNext><t path="com.haxepunk.FriendEntity"/></_renderNext>
			<_recycleNext><c path="com.haxepunk.Entity"/></_recycleNext>
			<_layer><c path="Int"/></_layer>
			<_class><c path="String"/></_class>
			<_added><e path="Bool"/></_added>
		</a>
		<haxe_doc>
 * Friend class used by World
 </haxe_doc>
	</typedef>
	<typedef path="com.haxepunk.AssignCallback" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Graphic.hx" module="com.haxepunk.Graphic"><f a=""><e path="Void"/></f></typedef>
	<class path="com.haxepunk.Graphic" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Graphic.hx">
		<active public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the graphic should update.
	 </haxe_doc>
		</active>
		<visible public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the graphic should render.
	 </haxe_doc>
		</visible>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>
	 * X offset.
	 </haxe_doc>
		</x>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Y offset.
	 </haxe_doc>
		</y>
		<scrollX public="1">
			<c path="Float"/>
			<haxe_doc>
	 * X scrollfactor, effects how much the camera offsets the drawn graphic.
	 * Can be used for parallax effect, eg. Set to 0 to follow the camera,
	 * 0.5 to move at half-speed of the camera, or 1 (default) to stay still.
	 </haxe_doc>
		</scrollX>
		<scrollY public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Y scrollfactor, effects how much the camera offsets the drawn graphic.
	 * Can be used for parallax effect, eg. Set to 0 to follow the camera,
	 * 0.5 to move at half-speed of the camera, or 1 (default) to stay still.
	 </haxe_doc>
		</scrollY>
		<relative public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the graphic should render at its position relative to its parent Entity's position.
	 </haxe_doc>
		</relative>
		<update public="1" set="method" line="66">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates the graphic.
	 </haxe_doc>
		</update>
		<render public="1" set="method" line="76">
			<f a="target:point:camera">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Renders the graphic to the screen buffer.
	 * @param	point		The position to draw the graphic.
	 * @param	camera		The camera offset.
	 </haxe_doc>
		</render>
		<assign public="1" set="null">
			<t path="com.haxepunk.AssignCallback"/>
			<haxe_doc> @private Callback for when the graphic is assigned to an Entity. </haxe_doc>
		</assign>
		<_scroll><e path="Bool"/></_scroll>
		<_point><c path="flash.geom.Point"/></_point>
		<new public="1" set="method" line="52">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
	</class>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<pan public="1"><c path="Float"/></pan>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<volume public="1"><c path="Float"/></volume>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><c path="Float"/></length>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1"><f a="sourcePoint">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<setTo public="1"><f a="xa:ya">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<a public="1"><c path="Float"/></a>
		<b public="1"><c path="Float"/></b>
		<c public="1"><c path="Float"/></c>
		<d public="1"><c path="Float"/></d>
		<tx public="1"><c path="Float"/></tx>
		<ty public="1"><c path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<copyColumnFrom public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1"><f a="sourceMatrix">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<setTo public="1"><f a="aa:ba:ca:da:txa:tya">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<bottom public="1"><c path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><c path="Float"/></height>
		<left public="1"><c path="Float"/></left>
		<right public="1"><c path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><c path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<copyFrom public="1"><f a="sourceRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<setTo public="1"><f a="xa:ya:widtha:heighta">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.haxepunk.HXP" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/HXP.hx">
		<VERSION public="1" get="inline" set="null" line="32" static="1">
			<c path="String"/>
			<haxe_doc>
	 * The HaxePunk major version.
	 </haxe_doc>
		</VERSION>
		<BASELAYER public="1" get="inline" set="null" line="37" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * The standard layer used since only flash can handle negative indicies in arrays, set your layers to some offset of this
	 </haxe_doc>
		</BASELAYER>
		<NUMBER_MAX_VALUE public="1" get="inline" set="null" line="43" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Flash equivalent: Number.MAX_VALUE
	 </haxe_doc>
		</NUMBER_MAX_VALUE>
		<blackColor public="1" get="inline" set="null" line="54" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * The color black defined for neko (BitmapInt32) or flash (Int)
	 </haxe_doc>
		</blackColor>
		<width public="1" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Width of the game.
	 </haxe_doc>
		</width>
		<height public="1" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Height of the game.
	 </haxe_doc>
		</height>
		<fixed public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the game is running at a fixed framerate.
	 </haxe_doc>
		</fixed>
		<frameRate public="1" line="75" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * The framerate assigned to the stage.
	 </haxe_doc>
		</frameRate>
		<assignedFrameRate public="1" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * The framerate assigned to the stage.
	 </haxe_doc>
		</assignedFrameRate>
		<elapsed public="1" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Time elapsed since the last frame (non-fixed framerate only).
	 </haxe_doc>
		</elapsed>
		<rate public="1" line="90" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Timescale applied to HXP.elapsed (non-fixed framerate only).
	 </haxe_doc>
		</rate>
		<screen public="1" static="1">
			<c path="com.haxepunk.Screen"/>
			<haxe_doc>
	 * The Screen object, use to transform or offset the Screen.
	 </haxe_doc>
		</screen>
		<buffer public="1" static="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>
	 * The current screen buffer, drawn to in the render loop.
	 </haxe_doc>
		</buffer>
		<bounds public="1" static="1">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>
	 * A rectangle representing the size of the screen.
	 </haxe_doc>
		</bounds>
		<defaultFont public="1" line="111" static="1">
			<c path="String"/>
			<haxe_doc>
	 * The default font file to use
	 </haxe_doc>
		</defaultFont>
		<camera public="1" line="119" static="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * Point used to determine drawing offset in the render loop.
	 </haxe_doc>
		</camera>
		<tweener public="1" line="124" static="1">
			<c path="com.haxepunk.Tweener"/>
			<haxe_doc>
	 * Global tweener for tweening between multiple worlds
	 </haxe_doc>
		</tweener>
		<focused public="1" line="129" static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether the game has focus or not
	 </haxe_doc>
		</focused>
		<halfWidth public="1" set="null" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Half the screen width.
	 </haxe_doc>
		</halfWidth>
		<halfHeight public="1" set="null" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Half the screen height.
	 </haxe_doc>
		</halfHeight>
		<world public="1" get="getWorld" set="setWorld" static="1">
			<c path="com.haxepunk.World"/>
			<haxe_doc>
	 * The currently active World object. When you set this, the World is flagged
	 * to switch, but won't actually do so until the end of the current frame.
	 </haxe_doc>
		</world>
		<getWorld get="inline" set="null" line="146" static="1"><f a=""><c path="com.haxepunk.World"/></f></getWorld>
		<setWorld set="method" line="147" static="1"><f a="value">
	<c path="com.haxepunk.World"/>
	<c path="com.haxepunk.World"/>
</f></setWorld>
		<swapWorld public="1" get="inline" set="null" line="154" static="1"><f a=""><e path="Void"/></f></swapWorld>
		<resize public="1" set="method" line="165" static="1">
			<f a="width:height">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Resize the screen.
	 * @param width		New width.
	 * @param height	New height.
	 </haxe_doc>
		</resize>
		<clear public="1" get="inline" set="null" line="180" static="1">
			<f a="array">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Empties an array of its' contents
	 * @param array filled array
	 </haxe_doc>
		</clear>
		<setCamera public="1" get="inline" set="null" line="192" static="1">
			<f a="?x:?y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the camera position.
	 * @param	x	X position.
	 * @param	y	Y position.
	 </haxe_doc>
		</setCamera>
		<resetCamera public="1" get="inline" set="null" line="201" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resets the camera position.
	 </haxe_doc>
		</resetCamera>
		<volume public="1" get="getVolume" set="setVolume" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Global volume factor for all sounds, a value from 0 to 1.
	 </haxe_doc>
		</volume>
		<getVolume get="inline" set="null" line="210" static="1"><f a=""><c path="Float"/></f></getVolume>
		<setVolume set="method" line="211" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setVolume>
		<pan public="1" get="getPan" set="setPan" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Global panning factor for all sounds, a value from -1 to 1.
	 </haxe_doc>
		</pan>
		<getPan get="inline" set="null" line="226" static="1"><f a=""><c path="Float"/></f></getPan>
		<setPan set="method" line="227" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setPan>
		<choose public="1" get="inline" set="null" line="244" static="1">
			<f a="objs">
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
	 * Randomly chooses and returns one of the provided values.
	 * @param	objs		The Objects you want to randomly choose from. Can be ints, Floats, Points, etc.
	 * @return	A randomly chosen one of the provided parameters.
	 </haxe_doc>
		</choose>
		<sign public="1" get="inline" set="null" line="254" static="1">
			<f a="value">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Finds the sign of the provided value.
	 * @param	value		The Float to evaluate.
	 * @return	1 if value > 0, -1 if value < 0, and 0 when value == 0.
	 ]]></haxe_doc>
		</sign>
		<approach public="1" get="inline" set="null" line="266" static="1">
			<f a="value:target:amount">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Approaches the value towards the target, by the specified amount, without overshooting the target.
	 * @param	value	The starting value.
	 * @param	target	The target that you want value to approach.
	 * @param	amount	How much you want the value to approach target by.
	 * @return	The new value.
	 </haxe_doc>
		</approach>
		<lerp public="1" get="inline" set="null" line="278" static="1">
			<f a="a:b:?t">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Linear interpolation between two values.
	 * @param	a		First value.
	 * @param	b		Second value.
	 * @param	t		Interpolation factor.
	 * @return	When t=0, returns a. When t=1, returns b. When t=0.5, will return halfway between a and b. Etc.
	 </haxe_doc>
		</lerp>
		<colorLerp public="1" get="inline" set="null" line="290" static="1">
			<f a="fromColor:toColor:?t">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Linear interpolation between two colors.
	 * @param	fromColor		First color.
	 * @param	toColor			Second color.
	 * @param	t				Interpolation value. Clamped to the range [0, 1].
	 * return	RGB component-interpolated color value.
	 </haxe_doc>
		</colorLerp>
		<stepTowards public="1" set="method" line="316" static="1">
			<f a="object:x:y:?distance">
				<d/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Steps the object towards a point.
	 * @param	object		Object to move (must have an x and y property).
	 * @param	x			X position to step towards.
	 * @param	y			Y position to step towards.
	 * @param	distance	The distance to step (will not overshoot target).
	 </haxe_doc>
		</stepTowards>
		<anchorTo public="1" get="inline" set="null" line="337" static="1">
			<f a="object:anchor:?distance">
				<d/>
				<d/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Anchors the object to a position.
	 * @param	object		The object to anchor.
	 * @param	anchor		The anchor object.
	 * @param	distance	The max distance object can be anchored to the anchor.
	 </haxe_doc>
		</anchorTo>
		<angle public="1" get="inline" set="null" line="354" static="1">
			<f a="x1:y1:x2:y2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Finds the angle (in degrees) from point 1 to point 2.
	 * @param	x1		The first x-position.
	 * @param	y1		The first y-position.
	 * @param	x2		The second x-position.
	 * @param	y2		The second y-position.
	 * @return	The angle from (x1, y1) to (x2, y2).
	 </haxe_doc>
		</angle>
		<angleXY public="1" get="inline" set="null" line="368" static="1">
			<f a="object:angle:?length:?x:?y">
				<d/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the x/y values of the provided object to a vector of the specified angle and length.
	 * @param	object		The object whose x/y properties should be set.
	 * @param	angle		The angle of the vector, in degrees.
	 * @param	length		The distance to the vector from (0, 0).
	 * @param	x			X offset.
	 * @param	y			Y offset.
	 </haxe_doc>
		</angleXY>
		<rotateAround public="1" get="inline" set="null" line="381" static="1">
			<f a="object:anchor:?angle:?relative">
				<d/>
				<d/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Rotates the object around the anchor by the specified amount.
	 * @param	object		Object to rotate around the anchor.
	 * @param	anchor		Anchor to rotate around.
	 * @param	angle		The amount of degrees to rotate by.
	 </haxe_doc>
		</rotateAround>
		<distance public="1" get="inline" set="null" line="395" static="1">
			<f a="x1:y1:?x2:?y2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Find the distance between two points.
	 * @param	x1		The first x-position.
	 * @param	y1		The first y-position.
	 * @param	x2		The second x-position.
	 * @param	y2		The second y-position.
	 * @return	The distance.
	 </haxe_doc>
		</distance>
		<distanceSquared public="1" get="inline" set="null" line="400" static="1"><f a="x1:y1:?x2:?y2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></distanceSquared>
		<distanceRects public="1" set="method" line="417" static="1">
			<f a="x1:y1:w1:h1:x2:y2:w2:h2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Find the distance between two rectangles. Will return 0 if the rectangles overlap.
	 * @param	x1		The x-position of the first rect.
	 * @param	y1		The y-position of the first rect.
	 * @param	w1		The width of the first rect.
	 * @param	h1		The height of the first rect.
	 * @param	x2		The x-position of the second rect.
	 * @param	y2		The y-position of the second rect.
	 * @param	w2		The width of the second rect.
	 * @param	h2		The height of the second rect.
	 * @return	The distance.
	 </haxe_doc>
		</distanceRects>
		<distanceRectPoint public="1" set="method" line="449" static="1">
			<f a="px:py:rx:ry:rw:rh">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Find the distance between a point and a rectangle. Returns 0 if the point is within the rectangle.
	 * @param	px		The x-position of the point.
	 * @param	py		The y-position of the point.
	 * @param	rx		The x-position of the rect.
	 * @param	ry		The y-position of the rect.
	 * @param	rw		The width of the rect.
	 * @param	rh		The height of the rect.
	 * @return	The distance.
	 </haxe_doc>
		</distanceRectPoint>
		<clamp public="1" set="method" line="478" static="1">
			<f a="value:min:max">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Clamps the value within the minimum and maximum values.
	 * @param	value		The Float to evaluate.
	 * @param	min			The minimum range.
	 * @param	max			The maximum range.
	 * @return	The clamped value.
	 </haxe_doc>
		</clamp>
		<clampInRect public="1" get="inline" set="null" line="497" static="1">
			<f a="object:x:y:width:height:?padding">
				<d/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Clamps the object inside the rectangle.
	 * @param	object		The object to clamp (must have an x and y property).
	 * @param	x			Rectangle's x.
	 * @param	y			Rectangle's y.
	 * @param	width		Rectangle's width.
	 * @param	height		Rectangle's height.
	 </haxe_doc>
		</clampInRect>
		<scale public="1" get="inline" set="null" line="512" static="1">
			<f a="value:min:max:min2:max2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Transfers a value from one scale to another scale. For example, scale(.5, 0, 1, 10, 20) == 15, and scale(3, 0, 5, 100, 0) == 40.
	 * @param	value		The value on the first scale.
	 * @param	min			The minimum range of the first scale.
	 * @param	max			The maximum range of the first scale.
	 * @param	min2		The minimum range of the second scale.
	 * @param	max2		The maximum range of the second scale.
	 * @return	The scaled value.
	 </haxe_doc>
		</scale>
		<scaleClamp public="1" set="method" line="526" static="1">
			<f a="value:min:max:min2:max2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Transfers a value from one scale to another scale, but clamps the return value within the second scale.
	 * @param	value		The value on the first scale.
	 * @param	min			The minimum range of the first scale.
	 * @param	max			The maximum range of the first scale.
	 * @param	min2		The minimum range of the second scale.
	 * @param	max2		The maximum range of the second scale.
	 * @return	The scaled and clamped value.
	 </haxe_doc>
		</scaleClamp>
		<randomSeed public="1" get="getRandomSeed" set="setRandomSeed" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * The random seed used by FP's random functions.
	 </haxe_doc>
		</randomSeed>
		<getRandomSeed get="inline" set="null" line="542" static="1"><f a=""><c path="Int"/></f></getRandomSeed>
		<setRandomSeed get="inline" set="null" line="543" static="1"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setRandomSeed>
		<randomizeSeed public="1" get="inline" set="null" line="553" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Randomizes the random seed using Flash's Math.random() function.
	 </haxe_doc>
		</randomizeSeed>
		<random public="1" get="getRandom" set="null" static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[
	 * A pseudo-random Float produced using FP's random seed, where 0 <= Float < 1.
	 ]]></haxe_doc>
		</random>
		<getRandom get="inline" set="null" line="562" static="1"><f a=""><c path="Float"/></f></getRandom>
		<rand public="1" get="inline" set="null" line="573" static="1">
			<f a="amount">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Returns a pseudo-random Int.
	 * @param	amount		The returned Int will always be 0 <= Int < amount.
	 * @return	The Int.
	 ]]></haxe_doc>
		</rand>
		<indexOf params="T" set="method" line="579" static="1"><f a="a:v">
	<c path="Array"><c path="indexOf.T"/></c>
	<c path="indexOf.T"/>
	<c path="Int"/>
</f></indexOf>
		<next public="1" params="T" get="inline" set="null" line="597" static="1">
			<f a="current:options:?loop">
				<c path="next.T"/>
				<c path="Array"><c path="next.T"/></c>
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
	 * Returns the next item after current in the list of options.
	 * @param	current		The currently selected item (must be one of the options).
	 * @param	options		An array of all the items to cycle through.
	 * @param	loop		If true, will jump to the first item after the last item is reached.
	 * @return	The next item in the list.
	 </haxe_doc>
		</next>
		<prev public="1" params="T" get="inline" set="null" line="612" static="1">
			<f a="current:options:?loop">
				<c path="prev.T"/>
				<c path="Array"><c path="prev.T"/></c>
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
	 * Returns the item previous to the current in the list of options.
	 * @param	current		The currently selected item (must be one of the options).
	 * @param	options		An array of all the items to cycle through.
	 * @param	loop		If true, will jump to the last item after the first is reached.
	 * @return	The previous item in the list.
	 </haxe_doc>
		</prev>
		<swap public="1" get="inline" set="null" line="627" static="1">
			<f a="current:a:b">
				<d/>
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc>
	 * Swaps the current item between a and b. Useful for quick state/string/value swapping.
	 * @param	current		The currently selected item.
	 * @param	a			Item a.
	 * @param	b			Item b.
	 * @return	Returns a if current is b, and b if current is a.
	 </haxe_doc>
		</swap>
		<getColorRGB public="1" get="inline" set="null" line="639" static="1">
			<f a="?R:?G:?B">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Creates a color value by combining the chosen RGB values.
	 * @param	R		The red value of the color, from 0 to 255.
	 * @param	G		The green value of the color, from 0 to 255.
	 * @param	B		The blue value of the color, from 0 to 255.
	 * @return	The color Int.
	 </haxe_doc>
		</getColorRGB>
		<getColorHSV public="1" set="method" line="651" static="1">
			<f a="h:s:v">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Creates a color value with the chosen HSV values.
	 * @param	h		The hue of the color (from 0 to 1).
	 * @param	s		The saturation of the color (from 0 to 1).
	 * @param	v		The value of the color (from 0 to 1).
	 * @return	The color Int.
	 </haxe_doc>
		</getColorHSV>
		<getRed public="1" get="inline" set="null" line="677" static="1">
			<f a="color">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Finds the red factor of a color.
	 * @param	color		The color to evaluate.
	 * @return	A Int from 0 to 255.
	 </haxe_doc>
		</getRed>
		<getGreen public="1" get="inline" set="null" line="687" static="1">
			<f a="color">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Finds the green factor of a color.
	 * @param	color		The color to evaluate.
	 * @return	A Int from 0 to 255.
	 </haxe_doc>
		</getGreen>
		<getBlue public="1" get="inline" set="null" line="697" static="1">
			<f a="color">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Finds the blue factor of a color.
	 * @param	color		The color to evaluate.
	 * @return	A Int from 0 to 255.
	 </haxe_doc>
		</getBlue>
		<getBitmap public="1" set="method" line="707" static="1">
			<f a="source">
				<d/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>
	 * Fetches a stored BitmapData object represented by the source.
	 * @param	source		Embedded Bitmap class.
	 * @return	The stored BitmapData object.
	 </haxe_doc>
		</getBitmap>
		<createBitmap public="1" set="method" line="727" static="1">
			<f a="width:height:?transparent:?color">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>
	 * Creates BitmapData based on platform specifics
	 </haxe_doc>
		</createBitmap>
		<convertColor public="1" get="inline" set="null" line="748" static="1">
			<f a="color">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
	 * Converts a color to platform specific type (BitmapInt32)
	 </haxe_doc>
		</convertColor>
		<timeFlag public="1" get="inline" set="null" line="804" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Sets a time flag.
	 * @return	Time elapsed (in milliseconds) since the last time flag was set.
	 </haxe_doc>
		</timeFlag>
		<console public="1" get="getConsole" set="null" static="1">
			<c path="com.haxepunk.debug.Console"/>
			<haxe_doc>
	 * The global Console object.
	 </haxe_doc>
		</console>
		<getConsole get="inline" set="null" line="816" static="1"><f a=""><c path="com.haxepunk.debug.Console"/></f></getConsole>
		<log public="1" line="826" static="1">
			<d/>
			<haxe_doc>
	 * Logs data to the console.
	 * @param	...data		The data parameters to log, can be variables, objects, etc. Parameters will be separated by a space (" ").
	 </haxe_doc>
		</log>
		<watch public="1" line="838" static="1">
			<d/>
			<haxe_doc>
	 * Adds properties to watch in the console's debug panel.
	 * @param	...properties		The properties (strings) to watch.
	 </haxe_doc>
		</watch>
		<tween public="1" set="method" line="860" static="1">
			<f a="object:values:duration:?options">
				<d/>
				<d/>
				<c path="Float"/>
				<d/>
				<c path="com.haxepunk.tweens.misc.MultiVarTween"/>
			</f>
			<haxe_doc>
	 * Tweens numeric public properties of an Object. Shorthand for creating a MultiVarTween tween, starting it and adding it to a Tweener.
	 * @param	object		The object containing the properties to tween.
	 * @param	values		An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.
	 * @param	options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * 						tweener		The Tweener to add this Tween to.
	 * @return	The added MultiVarTween object.
	 *
	 * Example: HXP.tween(object, { x: 500, y: 350 }, 2.0, { ease: easeFunction, complete: onComplete } );
	 </haxe_doc>
		</tween>
		<frames public="1" set="method" line="886" static="1">
			<f a="from:to:?skip">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Int"/></c>
			</f>
			<haxe_doc>
	 * Gets an array of frame indices.
	 * @param	from	Starting frame.
	 * @param	to		Ending frame.
	 * @param	skip	Skip amount every frame (eg. use 1 for every 2nd frame).
	 </haxe_doc>
		</frames>
		<shuffle public="1" set="method" line="913" static="1">
			<f a="a">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Shuffles the elements in the array.
	 * @param	a		The Object to shuffle (an Array or Vector).
	 </haxe_doc>
		</shuffle>
		<time public="1" get="null" set="setTime" static="1"><c path="Float"/></time>
		<setTime get="inline" set="null" line="928" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setTime>
		<gotoIsNull public="1" get="inline" set="null" line="933" static="1"><f a=""><e path="Bool"/></f></gotoIsNull>
		<_world line="936" static="1"><c path="com.haxepunk.World"/></_world>
		<_goto static="1"><c path="com.haxepunk.World"/></_goto>
		<_console static="1"><c path="com.haxepunk.debug.Console"/></_console>
		<_time static="1"><c path="Float"/></_time>
		<_updateTime public="1" static="1"><c path="Float"/></_updateTime>
		<_renderTime public="1" static="1"><c path="Float"/></_renderTime>
		<_gameTime public="1" static="1"><c path="Float"/></_gameTime>
		<_flashTime public="1" static="1"><c path="Float"/></_flashTime>
		<_bitmap line="950" static="1"><c path="Hash"><c path="flash.display.BitmapData"/></c></_bitmap>
		<_seed line="953" static="1"><c path="Int"/></_seed>
		<_getSeed static="1"><c path="Int"/></_getSeed>
		<_volume line="957" static="1"><c path="Float"/></_volume>
		<_pan line="958" static="1"><c path="Float"/></_pan>
		<_soundTransform line="959" static="1"><c path="flash.media.SoundTransform"/></_soundTransform>
		<DEG public="1" get="inline" set="null" line="965" static="1"><c path="Float"/></DEG>
		<RAD public="1" get="inline" set="null" line="966" static="1"><c path="Float"/></RAD>
		<stage public="1" static="1"><c path="flash.display.Stage"/></stage>
		<engine public="1" static="1"><c path="com.haxepunk.Engine"/></engine>
		<point public="1" line="973" static="1"><c path="flash.geom.Point"/></point>
		<point2 public="1" line="974" static="1"><c path="flash.geom.Point"/></point2>
		<zero public="1" line="975" static="1"><c path="flash.geom.Point"/></zero>
		<rect public="1" line="976" static="1"><c path="flash.geom.Rectangle"/></rect>
		<matrix public="1" line="977" static="1"><c path="flash.geom.Matrix"/></matrix>
		<sprite public="1" line="978" static="1"><c path="flash.display.Sprite"/></sprite>
		<entity public="1" static="1"><c path="com.haxepunk.Entity"/></entity>
		<haxe_doc>
 * Static catch-all class used to access global properties and functions.
 </haxe_doc>
	</class>
	<typedef path="com.haxepunk.MaskCallback" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Mask.hx" module="com.haxepunk.Mask"><f a="">
	<d/>
	<e path="Bool"/>
</f></typedef>
	<class path="com.haxepunk.Mask" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Mask.hx">
		<parent public="1">
			<c path="com.haxepunk.Entity"/>
			<haxe_doc>
	 * The parent Entity of this mask.
	 </haxe_doc>
		</parent>
		<list public="1">
			<c path="com.haxepunk.masks.Masklist"/>
			<haxe_doc>
	 * The parent Masklist of the mask.
	 </haxe_doc>
		</list>
		<collide public="1" set="method" line="41">
			<f a="mask">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Checks for collision with another Mask.
	 * @param	mask	The other Mask to check against.
	 * @return	If the Masks overlap.
	 </haxe_doc>
		</collide>
		<collideMask set="method" line="58">
			<f a="other">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collide against an Entity. </haxe_doc>
		</collideMask>
		<collideMasklist set="method" line="66"><f a="other">
	<c path="com.haxepunk.masks.Masklist"/>
	<e path="Bool"/>
</f></collideMasklist>
		<assignTo public="1" set="method" line="72">
			<f a="parent">
				<c path="com.haxepunk.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Assigns the mask to the parent. </haxe_doc>
		</assignTo>
		<debugDraw public="1" set="method" line="81">
			<f a="graphics:scaleX:scaleY">
				<c path="flash.display.Graphics"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Override this
	 </haxe_doc>
		</debugDraw>
		<update public="1" set="method" line="87">
			<f a=""><e path="Void"/></f>
			<haxe_doc> Updates the parent's bounds for this mask. </haxe_doc>
		</update>
		<projectMask public="1" get="inline" set="null" line="92"><f a="axis:collisionInfo">
	<c path="flash.geom.Point"/>
	<c path="com.haxepunk.masks.CollisionInfo"/>
	<e path="Void"/>
</f></projectMask>
		<_class><c path="String"/></_class>
		<_check><c path="Hash"><t path="com.haxepunk.MaskCallback"/></c></_check>
		<new public="1" set="method" line="29">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Base class for Entity collision masks.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.Screen" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Screen.hx">
		<init public="1" set="method" line="33"><f a=""><e path="Void"/></f></init>
		<resize public="1" set="method" line="50">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resizes the screen by recreating the bitmap buffer
	 * @param width the width of the screen
	 * @param height the height of the screen
	 </haxe_doc>
		</resize>
		<swap public="1" set="method" line="77">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Swaps screen buffers.
	 </haxe_doc>
		</swap>
		<addFilter public="1" set="method" line="83"><f a="filter">
	<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
	<e path="Void"/>
</f></addFilter>
		<refresh public="1" set="method" line="91">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Refreshes the screen.
	 </haxe_doc>
		</refresh>
		<redraw public="1" set="method" line="104">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Redraws the screen.
	 </haxe_doc>
		</redraw>
		<update public="1" set="method" line="112">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Re-applies transformation matrix. </haxe_doc>
		</update>
		<color public="1" get="getColor" set="setColor">
			<c path="Int"/>
			<haxe_doc>
	 * Refresh color of the screen.
	 </haxe_doc>
		</color>
		<getColor set="method" line="130"><f a=""><c path="Int"/></f></getColor>
		<setColor set="method" line="131"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setColor>
		<x public="1" set="setX">
			<c path="Int"/>
			<haxe_doc>
	 * X offset of the screen.
	 </haxe_doc>
		</x>
		<setX set="method" line="137"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setX>
		<y public="1" set="setY">
			<c path="Int"/>
			<haxe_doc>
	 * Y offset of the screen.
	 </haxe_doc>
		</y>
		<setY set="method" line="149"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setY>
		<originX public="1" set="setOriginX">
			<c path="Int"/>
			<haxe_doc>
	 * X origin of transformations.
	 </haxe_doc>
		</originX>
		<setOriginX set="method" line="161"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setOriginX>
		<originY public="1" set="setOriginY">
			<c path="Int"/>
			<haxe_doc>
	 * Y origin of transformations.
	 </haxe_doc>
		</originY>
		<setOriginY set="method" line="173"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setOriginY>
		<scaleX public="1" set="setScaleX">
			<c path="Float"/>
			<haxe_doc>
	 * X scale of the screen.
	 </haxe_doc>
		</scaleX>
		<setScaleX set="method" line="185"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setScaleX>
		<scaleY public="1" set="setScaleY">
			<c path="Float"/>
			<haxe_doc>
	 * Y scale of the screen.
	 </haxe_doc>
		</scaleY>
		<setScaleY set="method" line="197"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setScaleY>
		<scale public="1" set="setScale">
			<c path="Float"/>
			<haxe_doc>
	 * Scale factor of the screen. Final scale is scaleX * scale by scaleY * scale, so
	 * you can use this factor to scale the screen both horizontally and vertically.
	 </haxe_doc>
		</scale>
		<setScale set="method" line="210"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setScale>
		<angle public="1" get="getAngle" set="setAngle">
			<c path="Float"/>
			<haxe_doc>
	 * Rotation of the screen, in degrees.
	 </haxe_doc>
		</angle>
		<getAngle set="method" line="222"><f a=""><c path="Float"/></f></getAngle>
		<setAngle set="method" line="223"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setAngle>
		<smoothing public="1" get="getSmoothing" set="setSmoothing">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether screen smoothing should be used or not.
	 </haxe_doc>
		</smoothing>
		<getSmoothing set="method" line="235"><f a=""><e path="Bool"/></f></getSmoothing>
		<setSmoothing set="method" line="236"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setSmoothing>
		<width public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Width of the screen.
	 </haxe_doc>
		</width>
		<height public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Height of the screen.
	 </haxe_doc>
		</height>
		<mouseX public="1" get="getMouseX" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * X position of the mouse on the screen.
	 </haxe_doc>
		</mouseX>
		<getMouseX set="method" line="252"><f a=""><c path="Int"/></f></getMouseX>
		<mouseY public="1" get="getMouseY" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Y position of the mouse on the screen.
	 </haxe_doc>
		</mouseY>
		<getMouseY set="method" line="258"><f a=""><c path="Int"/></f></getMouseY>
		<capture public="1" set="method" line="264">
			<f a=""><c path="com.haxepunk.graphics.Image"/></f>
			<haxe_doc>
	 * Captures the current screen as an Image object.
	 * @return	A new Image object.
	 </haxe_doc>
		</capture>
		<_sprite><c path="flash.display.Sprite"/></_sprite>
		<_bitmap><c path="Array"><c path="flash.display.Bitmap"/></c></_bitmap>
		<_current><c path="Int"/></_current>
		<_matrix><c path="flash.geom.Matrix"/></_matrix>
		<_angle><c path="Float"/></_angle>
		<_color><c path="Int"/></_color>
		<new public="1" set="method" line="20">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Container for the main screen buffer. Can be used to transform the screen.
 </haxe_doc>
	</class>
	<enum path="com.haxepunk.TweenType" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Tween.hx" module="com.haxepunk.Tween">
		<Persist/>
		<OneShot/>
		<Looping/>
	</enum>
	<typedef path="com.haxepunk.CompleteCallback" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Tween.hx" module="com.haxepunk.Tween"><f a=""><e path="Void"/></f></typedef>
	<typedef path="com.haxepunk.FriendTween" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Tween.hx" module="com.haxepunk.Tween">
		<a>
			<finish set="method"><f a=""><e path="Void"/></f></finish>
			<_prev><t path="com.haxepunk.FriendTween"/></_prev>
			<_parent><c path="com.haxepunk.Tweener"/></_parent>
			<_next><t path="com.haxepunk.FriendTween"/></_next>
			<_finish><e path="Bool"/></_finish>
		</a>
		<haxe_doc>
 * Friend class for access to Tween private members
 </haxe_doc>
	</typedef>
	<class path="com.haxepunk.Tween" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/Tween.hx">
		<active public="1"><e path="Bool"/></active>
		<complete public="1"><t path="com.haxepunk.CompleteCallback"/></complete>
		<update public="1" set="method" line="51">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates the Tween, called by World.
	 </haxe_doc>
		</update>
		<start public="1" set="method" line="66">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Starts the Tween, or restarts it if it's currently running.
	 </haxe_doc>
		</start>
		<finish set="method" line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Called when the Tween completes. </haxe_doc>
		</finish>
		<percent public="1" get="getPercent" set="setPercent"><c path="Float"/></percent>
		<getPercent set="method" line="100"><f a=""><c path="Float"/></f></getPercent>
		<setPercent set="method" line="101"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setPercent>
		<scale public="1" get="getScale" set="null"><c path="Float"/></scale>
		<getScale set="method" line="104"><f a=""><c path="Float"/></f></getScale>
		<_type><e path="com.haxepunk.TweenType"/></_type>
		<_ease><t path="com.haxepunk.utils.EaseFunction"/></_ease>
		<_t><c path="Float"/></_t>
		<_time><c path="Float"/></_time>
		<_target><c path="Float"/></_target>
		<_finish><e path="Bool"/></_finish>
		<_parent><c path="com.haxepunk.Tweener"/></_parent>
		<_prev><t path="com.haxepunk.FriendTween"/></_prev>
		<_next><t path="com.haxepunk.FriendTween"/></_next>
		<new public="1" set="method" line="38">
			<f a="duration:?type:?complete:?ease">
				<c path="Float"/>
				<e path="com.haxepunk.TweenType"/>
				<t path="com.haxepunk.CompleteCallback"/>
				<t path="com.haxepunk.utils.EaseFunction"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor. Specify basic information about the Tween.
	 * @param	duration		Duration of the tween (in seconds or frames).
	 * @param	type			Tween type, one of Tween.PERSIST (default), Tween.LOOPING, or Tween.ONESHOT.
	 * @param	complete		Optional callback for when the Tween completes.
	 * @param	ease			Optional easer function to apply to the Tweened value.
	 </haxe_doc>
		</new>
	</class>
	<class path="com.haxepunk.debug.Console" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/debug/Console.hx">
		<toggleKey public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The key used to toggle the Console on/off.
	 </haxe_doc>
		</toggleKey>
		<init set="method" line="49"><f a=""><e path="Void"/></f></init>
		<traceLog set="method" line="99"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></traceLog>
		<log public="1" set="method" line="112">
			<f a="data">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Logs data to the console.
	 * @param	...data		The data parameters to log, can be variables, objects, etc. Parameters will be separated by a space (" ").
	 </haxe_doc>
		</log>
		<watch public="1" set="method" line="139">
			<f a="properties">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adds properties to watch in the console's debug panel.
	 * @param	...properties		The properties (strings) to watch.
	 </haxe_doc>
		</watch>
		<enable public="1" set="method" line="152">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Enables the console.
	 </haxe_doc>
		</enable>
		<onResize public="1" set="method" line="328"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onResize>
		<visible public="1" get="getVisible" set="setVisible">
			<e path="Bool"/>
			<haxe_doc>
	 * If the console should be visible.
	 </haxe_doc>
		</visible>
		<getVisible set="method" line="354"><f a=""><e path="Bool"/></f></getVisible>
		<setVisible set="method" line="355"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setVisible>
		<update public="1" set="method" line="365">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Console update, called by game loop.
	 </haxe_doc>
		</update>
		<paused public="1" get="getPaused" set="setPaused">
			<e path="Bool"/>
			<haxe_doc>
	 * If the Console is currently in paused mode.
	 </haxe_doc>
		</paused>
		<getPaused set="method" line="459"><f a=""><e path="Bool"/></f></getPaused>
		<setPaused set="method" line="460"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setPaused>
		<debug public="1" get="getDebug" set="setDebug">
			<e path="Bool"/>
			<haxe_doc>
	 * If the Console is currently in debug mode.
	 </haxe_doc>
		</debug>
		<getDebug set="method" line="498"><f a=""><e path="Bool"/></f></getDebug>
		<setDebug set="method" line="499"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setDebug>
		<stepFrame set="method" line="517">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Steps the frame ahead. </haxe_doc>
		</stepFrame>
		<startDragging set="method" line="527">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Starts Entity dragging. </haxe_doc>
		</startDragging>
		<updateDragging set="method" line="535">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates Entity dragging. </haxe_doc>
		</updateDragging>
		<moveSelected set="method" line="544">
			<f a="xDelta:yDelta">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Move the selected Entitites by the amount. </haxe_doc>
		</moveSelected>
		<startPanning set="method" line="558">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Starts camera panning. </haxe_doc>
		</startPanning>
		<updatePanning set="method" line="566">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates camera panning. </haxe_doc>
		</updatePanning>
		<panCamera set="method" line="575">
			<f a="xDelta:yDelta">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Pans the camera. </haxe_doc>
		</panCamera>
		<setCamera set="method" line="585">
			<f a="x:y">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Sets the camera position. </haxe_doc>
		</setCamera>
		<startSelection set="method" line="595">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Starts Entity selection. </haxe_doc>
		</startSelection>
		<updateSelection set="method" line="605">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates Entity selection. </haxe_doc>
		</updateSelection>
		<selectEntities set="method" line="625">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Selects the Entitites in the rectangle. </haxe_doc>
		</selectEntities>
		<selectAll set="method" line="664">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Selects all entities on screen. </haxe_doc>
		</selectAll>
		<startScrolling set="method" line="673">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Starts log text scrolling. </haxe_doc>
		</startScrolling>
		<updateScrolling set="method" line="679">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates log text scrolling. </haxe_doc>
		</updateScrolling>
		<updateKeyMoving set="method" line="687">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Moves Entities with the arrow keys. </haxe_doc>
		</updateKeyMoving>
		<updateKeyPanning set="method" line="695">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Pans the camera with the arrow keys. </haxe_doc>
		</updateKeyPanning>
		<updateEntityLists set="method" line="703">
			<f a="?fetchList">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Update the Entity list information. </haxe_doc>
		</updateEntityLists>
		<renderEntities set="method" line="723">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Renders the Entities positions and hitboxes. </haxe_doc>
		</renderEntities>
		<updateLog set="method" line="777">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates the log window. </haxe_doc>
		</updateLog>
		<updateFPSRead set="method" line="871">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Update the FPS/frame timing panel text. </haxe_doc>
		</updateFPSRead>
		<updateDebugRead set="method" line="884">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Update the debug panel text. </haxe_doc>
		</updateDebugRead>
		<updateEntityCount set="method" line="931">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates the Entity count text. </haxe_doc>
		</updateEntityCount>
		<updateButtons set="method" line="937">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates the Button panel. </haxe_doc>
		</updateButtons>
		<format set="method" line="976">
			<f a="?size:?color:?align">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<haxe_doc> @private Gets a TextFormat object with the formatting. </haxe_doc>
		</format>
		<width public="1" get="getWidth" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Get the unscaled screen size for the Console.
	 </haxe_doc>
		</width>
		<getWidth set="method" line="998"><f a=""><c path="Int"/></f></getWidth>
		<height public="1" get="getHeight" set="null"><c path="Int"/></height>
		<getHeight set="method" line="1001"><f a=""><c path="Int"/></f></getHeight>
		<_enabled><e path="Bool"/></_enabled>
		<_paused><e path="Bool"/></_paused>
		<_debug><e path="Bool"/></_debug>
		<_scrolling><e path="Bool"/></_scrolling>
		<_selecting><e path="Bool"/></_selecting>
		<_dragging><e path="Bool"/></_dragging>
		<_panning><e path="Bool"/></_panning>
		<_sprite><c path="flash.display.Sprite"/></_sprite>
		<_format><c path="flash.text.TextFormat"/></_format>
		<_back><c path="flash.display.Bitmap"/></_back>
		<_fpsRead><c path="flash.display.Sprite"/></_fpsRead>
		<_fpsReadText><c path="flash.text.TextField"/></_fpsReadText>
		<_fpsInfo><c path="flash.display.Sprite"/></_fpsInfo>
		<_fpsInfoText0><c path="flash.text.TextField"/></_fpsInfoText0>
		<_fpsInfoText1><c path="flash.text.TextField"/></_fpsInfoText1>
		<_logRead><c path="flash.display.Sprite"/></_logRead>
		<_logReadText0><c path="flash.text.TextField"/></_logReadText0>
		<_logReadText1><c path="flash.text.TextField"/></_logReadText1>
		<_logHeight><c path="Int"/></_logHeight>
		<_logBar><c path="flash.geom.Rectangle"/></_logBar>
		<_logBarGlobal><c path="flash.geom.Rectangle"/></_logBarGlobal>
		<_logScroll><c path="Float"/></_logScroll>
		<_entRead><c path="flash.display.Sprite"/></_entRead>
		<_entReadText><c path="flash.text.TextField"/></_entReadText>
		<_debRead><c path="flash.display.Sprite"/></_debRead>
		<_debReadText0><c path="flash.text.TextField"/></_debReadText0>
		<_debReadText1><c path="flash.text.TextField"/></_debReadText1>
		<_butRead><c path="flash.display.Sprite"/></_butRead>
		<_butDebug><c path="flash.display.Bitmap"/></_butDebug>
		<_butOutput><c path="flash.display.Bitmap"/></_butOutput>
		<_butPlay><c path="flash.display.Bitmap"/></_butPlay>
		<_butPause><c path="flash.display.Bitmap"/></_butPause>
		<_butStep><c path="flash.display.Bitmap"/></_butStep>
		<_bmpLogo><c path="flash.display.Bitmap"/></_bmpLogo>
		<_entScreen><c path="flash.display.Sprite"/></_entScreen>
		<_entSelect><c path="flash.display.Sprite"/></_entSelect>
		<_entRect><c path="flash.geom.Rectangle"/></_entRect>
		<_logLines><c path="Int"/></_logLines>
		<LOG><c path="Array"><c path="String"/></c></LOG>
		<ENTITY_LIST><c path="Array"><c path="com.haxepunk.Entity"/></c></ENTITY_LIST>
		<SCREEN_LIST><c path="List"><c path="com.haxepunk.Entity"/></c></SCREEN_LIST>
		<SELECT_LIST><c path="List"><c path="com.haxepunk.Entity"/></c></SELECT_LIST>
		<WATCH_LIST><c path="List"><c path="String"/></c></WATCH_LIST>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.haxepunk.graphics.Graphiclist" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/graphics/Graphiclist.hx">
		<extends path="com.haxepunk.Graphic"/>
		<update public="1" set="method" line="35" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates the graphics in the list. </haxe_doc>
		</update>
		<render public="1" set="method" line="45" override="1">
			<f a="target:point:camera">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Renders the Graphics in the list. </haxe_doc>
		</render>
		<add public="1" set="method" line="75">
			<f a="graphic">
				<c path="com.haxepunk.Graphic"/>
				<c path="com.haxepunk.Graphic"/>
			</f>
			<haxe_doc>
	 * Adds the Graphic to the list.
	 * @param	graphic		The Graphic to add.
	 * @return	The added Graphic.
	 </haxe_doc>
		</add>
		<remove public="1" set="method" line="87">
			<f a="graphic">
				<c path="com.haxepunk.Graphic"/>
				<c path="com.haxepunk.Graphic"/>
			</f>
			<haxe_doc>
	 * Removes the Graphic from the list.
	 * @param	graphic		The Graphic to remove.
	 * @return	The removed Graphic.
	 </haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="109">
			<f a="?index">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes the Graphic from the position in the list.
	 * @param	index		Index to remove.
	 </haxe_doc>
		</removeAt>
		<removeAll public="1" set="method" line="120">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes all Graphics from the list.
	 </haxe_doc>
		</removeAll>
		<children public="1" get="getChildren" set="null">
			<c path="Array"><c path="com.haxepunk.Graphic"/></c>
			<haxe_doc>
	 * All Graphics in this list.
	 </haxe_doc>
		</children>
		<getChildren set="method" line="132"><f a=""><c path="Array"><c path="com.haxepunk.Graphic"/></c></f></getChildren>
		<count public="1" get="getCount" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Amount of Graphics in this list.
	 </haxe_doc>
		</count>
		<getCount set="method" line="138"><f a=""><c path="Int"/></f></getCount>
		<updateCheck set="method" line="143">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Check if the Graphiclist should update.
	 </haxe_doc>
		</updateCheck>
		<_graphics><c path="Array"><c path="com.haxepunk.Graphic"/></c></_graphics>
		<_temp><c path="Array"><c path="com.haxepunk.Graphic"/></c></_temp>
		<_count><c path="Int"/></_count>
		<_camera><c path="flash.geom.Point"/></_camera>
		<new public="1" set="method" line="18">
			<f a="?graphic">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	...graphic		Graphic objects to add to the list.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A Graphic that can contain multiple Graphics of one or various types.
 * Useful for drawing sprites with multiple different parts, etc.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.graphics.Image" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/graphics/Image.hx">
		<extends path="com.haxepunk.Graphic"/>
		<createRect public="1" set="method" line="221" static="1">
			<f a="width:height:?color">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="com.haxepunk.graphics.Image"/>
			</f>
			<haxe_doc>
	 * Creates a new rectangle Image.
	 * @param	width		Width of the rectangle.
	 * @param	height		Height of the rectangle.
	 * @param	color		Color of the rectangle.
	 * @return	A new Image object.
	 </haxe_doc>
		</createRect>
		<createCircle public="1" set="method" line="233" static="1">
			<f a="radius:?color">
				<c path="Int"/>
				<c path="Int"/>
				<c path="com.haxepunk.graphics.Image"/>
			</f>
			<haxe_doc>
	 * Creates a new circle Image.
	 * @param	radius		Radius of the circle.
	 * @param	color		Color of the circle.
	 * @return	A new Circle object.
	 </haxe_doc>
		</createCircle>
		<_flips line="422" static="1"><c path="Hash"><c path="flash.display.BitmapData"/></c></_flips>
		<angle public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Rotation of the image, in degrees.
	 </haxe_doc>
		</angle>
		<scale public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Scale of the image, effects both x and y scale.
	 </haxe_doc>
		</scale>
		<scaleX public="1">
			<c path="Float"/>
			<haxe_doc>
	 * X scale of the image.
	 </haxe_doc>
		</scaleX>
		<scaleY public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Y scale of the image.
	 </haxe_doc>
		</scaleY>
		<originX public="1">
			<c path="Int"/>
			<haxe_doc>
	 * X origin of the image, determines transformation point.
	 </haxe_doc>
		</originX>
		<originY public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Y origin of the image, determines transformation point.
	 </haxe_doc>
		</originY>
		<blend public="1">
			<e path="flash.display.BlendMode"/>
			<haxe_doc>
	 * Optional blend mode to use when drawing this image.
	 * Use constants from the flash.display.BlendMode class.
	 </haxe_doc>
		</blend>
		<smooth public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If the image should be drawn transformed with pixel smoothing.
	 * This will affect drawing performance, but look less pixelly.
	 </haxe_doc>
		</smooth>
		<init set="method" line="124">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Initialize variables </haxe_doc>
		</init>
		<createBuffer set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Creates the buffer. </haxe_doc>
		</createBuffer>
		<render public="1" set="method" line="147" override="1">
			<f a="target:point:camera">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Renders the image. </haxe_doc>
		</render>
		<updateBuffer public="1" set="method" line="246">
			<f a="?clearBefore">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Updates the image buffer.
	 </haxe_doc>
		</updateBuffer>
		<clear public="1" set="method" line="257">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Clears the image buffer.
	 </haxe_doc>
		</clear>
		<alpha public="1" get="getAlpha" set="setAlpha">
			<c path="Float"/>
			<haxe_doc>
	 * Change the opacity of the Image, a value from 0 to 1.
	 </haxe_doc>
		</alpha>
		<getAlpha set="method" line="266"><f a=""><c path="Float"/></f></getAlpha>
		<setAlpha set="method" line="267"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setAlpha>
		<color public="1" get="getColor" set="setColor">
			<c path="Int"/>
			<haxe_doc>
	 * The tinted color of the Image. Use 0xFFFFFF to draw the Image normally.
	 </haxe_doc>
		</color>
		<getColor set="method" line="291"><f a=""><c path="Int"/></f></getColor>
		<setColor set="method" line="292"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setColor>
		<flipped public="1" get="getFlipped" set="setFlipped">
			<e path="Bool"/>
			<haxe_doc>
	 * If you want to draw the Image horizontally flipped. This is
	 * faster than setting scaleX to -1 if your image isn't transformed.
	 </haxe_doc>
		</flipped>
		<getFlipped set="method" line="317"><f a=""><e path="Bool"/></f></getFlipped>
		<setFlipped set="method" line="318"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setFlipped>
		<centerOrigin public="1" set="method" line="352">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Centers the Image's originX/Y to its center.
	 </haxe_doc>
		</centerOrigin>
		<centerOO public="1" set="method" line="361">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Centers the Image's originX/Y to its center, and negates the offset by the same amount.
	 </haxe_doc>
		</centerOO>
		<width public="1" get="getWidth" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Width of the image.
	 </haxe_doc>
		</width>
		<getWidth set="method" line="374"><f a=""><c path="Int"/></f></getWidth>
		<height public="1" get="getHeight" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Height of the image.
	 </haxe_doc>
		</height>
		<getHeight set="method" line="380"><f a=""><c path="Int"/></f></getHeight>
		<scaledWidth public="1" get="getScaledWidth" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The scaled width of the image.
	 </haxe_doc>
		</scaledWidth>
		<getScaledWidth set="method" line="386"><f a=""><c path="Int"/></f></getScaledWidth>
		<scaledHeight public="1" get="getScaledHeight" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The scaled height of the image.
	 </haxe_doc>
		</scaledHeight>
		<getScaledHeight set="method" line="392"><f a=""><c path="Int"/></f></getScaledHeight>
		<clipRect public="1" get="getClipRect" set="null">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>
	 * Clipping rectangle for the image.
	 </haxe_doc>
		</clipRect>
		<getClipRect set="method" line="398"><f a=""><c path="flash.geom.Rectangle"/></f></getClipRect>
		<source get="getSource" set="null">
			<c path="flash.display.BitmapData"/>
			<haxe_doc> @private Source BitmapData image. </haxe_doc>
		</source>
		<getSource set="method" line="402"><f a=""><c path="flash.display.BitmapData"/></f></getSource>
		<_source><c path="flash.display.BitmapData"/></_source>
		<_sourceRect><c path="flash.geom.Rectangle"/></_sourceRect>
		<_buffer><c path="flash.display.BitmapData"/></_buffer>
		<_bufferRect><c path="flash.geom.Rectangle"/></_bufferRect>
		<_bitmap><c path="flash.display.Bitmap"/></_bitmap>
		<_alpha><c path="Float"/></_alpha>
		<_color><c path="Int"/></_color>
		<_tint><c path="flash.geom.ColorTransform"/></_tint>
		<_colorTransform><c path="flash.geom.ColorTransform"/></_colorTransform>
		<_matrix><c path="flash.geom.Matrix"/></_matrix>
		<_class><c path="String"/></_class>
		<_flipped><e path="Bool"/></_flipped>
		<_flip><c path="flash.display.BitmapData"/></_flip>
		<new public="1" set="method" line="71">
			<f a="source:?clipRect:?name">
				<d/>
				<c path="flash.geom.Rectangle"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	source		Source image.
	 * @param	clipRect	Optional rectangle defining area of the source image to draw.
	 * @param	name		Optional name, necessary to identify the bitmapData if you are using flipped
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Performance-optimized non-animated image. Can be drawn to the screen with transformations.
 </haxe_doc>
	</class>
	<typedef path="com.haxepunk.graphics.TextOptions" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/graphics/Text.hx" module="com.haxepunk.graphics.Text"><a>
	<wordWrap><e path="Bool"/></wordWrap>
	<size><c path="Int"/></size>
	<resizable><e path="Bool"/></resizable>
	<leading><c path="Float"/></leading>
	<font><c path="String"/></font>
	<color><c path="Int"/></color>
	<align><e path="flash.text.TextFormatAlign"/></align>
</a></typedef>
	<class path="com.haxepunk.graphics.Text" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/graphics/Text.hx">
		<extends path="com.haxepunk.graphics.Image"/>
		<updateBuffer public="1" set="method" line="89" override="1">
			<f a="?clearBefore">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc> @private Updates the drawing buffer. </haxe_doc>
		</updateBuffer>
		<resizable public="1"><e path="Bool"/></resizable>
		<textWidth public="1" set="null"><c path="Int"/></textWidth>
		<textHeight public="1" set="null"><c path="Int"/></textHeight>
		<text public="1" set="setText">
			<c path="String"/>
			<haxe_doc>
	 * Text string.
	 </haxe_doc>
		</text>
		<setText set="method" line="133"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></setText>
		<font public="1" set="setFont">
			<c path="String"/>
			<haxe_doc>
	 * Font family.
	 </haxe_doc>
		</font>
		<setFont set="method" line="145"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></setFont>
		<size public="1" set="setSize">
			<c path="Int"/>
			<haxe_doc>
	 * Font size.
	 </haxe_doc>
		</size>
		<setSize set="method" line="157"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setSize>
		<getWidth set="method" line="168" override="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Width of the text image.
	 </haxe_doc>
		</getWidth>
		<getHeight set="method" line="173" override="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Height of the text image.
	 </haxe_doc>
		</getHeight>
		<_field><c path="flash.text.TextField"/></_field>
		<_form><c path="flash.text.TextFormat"/></_form>
		<new public="1" set="method" line="42">
			<f a="text:?x:?y:?width:?height:?options">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<t path="com.haxepunk.graphics.TextOptions"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param text    Text to display.
	 * @param x       X offset.
	 * @param y       Y offset.
	 * @param width   Image width (leave as 0 to size to the starting text string).
	 * @param height  Image height (leave as 0 to size to the starting text string).
	 * @param options An object containing optional parameters contained in TextOptions
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Used for drawing text using embedded fonts.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.Circle" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/Circle.hx">
		<extends path="com.haxepunk.Mask"/>
		<collideMask set="method" line="35" override="1">
			<f a="other">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against an Entity. </haxe_doc>
		</collideMask>
		<collideCircle set="method" line="55"><f a="other">
	<c path="com.haxepunk.masks.Circle"/>
	<e path="Bool"/>
</f></collideCircle>
		<collideGrid set="method" line="62"><f a="other">
	<c path="com.haxepunk.masks.Grid"/>
	<e path="Bool"/>
</f></collideGrid>
		<collideHitbox set="method" line="133">
			<f a="other">
				<c path="com.haxepunk.masks.Hitbox"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against a Hitbox. </haxe_doc>
		</collideHitbox>
		<projectOn public="1" get="inline" set="null" line="150"><f a="axis:collisionInfo">
	<c path="flash.geom.Point"/>
	<c path="com.haxepunk.masks.CollisionInfo"/>
	<e path="Void"/>
</f></projectOn>
		<debugDraw public="1" set="method" line="156" override="1"><f a="graphics:scaleX:scaleY">
	<c path="flash.display.Graphics"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></debugDraw>
		<x public="1" get="getX" set="setX">
			<c path="Int"/>
			<haxe_doc>
	 * X offset.
	 </haxe_doc>
		</x>
		<getX get="inline" set="null" line="165"><f a=""><c path="Int"/></f></getX>
		<setX set="method" line="166"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setX>
		<y public="1" get="getY" set="setY">
			<c path="Int"/>
			<haxe_doc>
	 * Y offset.
	 </haxe_doc>
		</y>
		<getY get="inline" set="null" line="179"><f a=""><c path="Int"/></f></getY>
		<setY set="method" line="180"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setY>
		<radius public="1" get="getRadius" set="setRadius">
			<c path="Int"/>
			<haxe_doc>
	 * Radius.
	 </haxe_doc>
		</radius>
		<getRadius get="inline" set="null" line="193"><f a=""><c path="Int"/></f></getRadius>
		<setRadius set="method" line="194"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setRadius>
		<update public="1" set="method" line="205" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc> Updates the parent's bounds for this mask. </haxe_doc>
		</update>
		<_x><c path="Int"/></_x>
		<_y><c path="Int"/></_y>
		<_radius><c path="Int"/></_radius>
		<_squaredRadius><c path="Int"/></_squaredRadius>
		<new public="1" set="method" line="21">
			<f a="?radius:?x:?y">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	radius		Radius of the circle.
	 * @param	x			X offset of the circle.
	 * @param	y			Y offset of the circle.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Uses circular area to determine collision.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.CollisionInfo" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/CollisionInfo.hx">
		<max public="1"><c path="Float"/></max>
		<min public="1"><c path="Float"/></min>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * ...
 * @author 
 </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.Hitbox" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/Hitbox.hx">
		<extends path="com.haxepunk.Mask"/>
		<collideMask set="method" line="30" override="1">
			<f a="other">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against an Entity. </haxe_doc>
		</collideMask>
		<collideHitbox set="method" line="39">
			<f a="other">
				<c path="com.haxepunk.masks.Hitbox"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against a Hitbox. </haxe_doc>
		</collideHitbox>
		<x public="1" get="getX" set="setX">
			<c path="Int"/>
			<haxe_doc>
	 * X offset.
	 </haxe_doc>
		</x>
		<getX set="method" line="51"><f a=""><c path="Int"/></f></getX>
		<setX set="method" line="52"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setX>
		<y public="1" get="getY" set="setY">
			<c path="Int"/>
			<haxe_doc>
	 * Y offset.
	 </haxe_doc>
		</y>
		<getY set="method" line="65"><f a=""><c path="Int"/></f></getY>
		<setY set="method" line="66"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setY>
		<width public="1" get="getWidth" set="setWidth">
			<c path="Int"/>
			<haxe_doc>
	 * Width.
	 </haxe_doc>
		</width>
		<getWidth set="method" line="79"><f a=""><c path="Int"/></f></getWidth>
		<setWidth set="method" line="80"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setWidth>
		<height public="1" get="getHeight" set="setHeight">
			<c path="Int"/>
			<haxe_doc>
	 * Height.
	 </haxe_doc>
		</height>
		<getHeight set="method" line="93"><f a=""><c path="Int"/></f></getHeight>
		<setHeight set="method" line="94"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setHeight>
		<update public="1" set="method" line="104" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc> Updates the parent's bounds for this mask. </haxe_doc>
		</update>
		<_width><c path="Int"/></_width>
		<_height><c path="Int"/></_height>
		<_x><c path="Int"/></_x>
		<_y><c path="Int"/></_y>
		<new public="1" set="method" line="19">
			<f a="?width:?height:?x:?y">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	width		Width of the hitbox.
	 * @param	height		Height of the hitbox.
	 * @param	x			X offset of the hitbox.
	 * @param	y			Y offset of the hitbox.
	 </haxe_doc>
		</new>
		<haxe_doc> Uses parent's hitbox to determine collision.
 * This class is used * internally by FlashPunk, you don't need to use this class because
 * this is the default behaviour of Entities without a Mask object. </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.Grid" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/Grid.hx">
		<extends path="com.haxepunk.masks.Hitbox"/>
		<usePositions public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If x/y positions should be used instead of columns/rows.
	 </haxe_doc>
		</usePositions>
		<setTile public="1" set="method" line="75">
			<f a="?column:?row:?solid">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the value of the tile.
	 * @param	column		Tile column.
	 * @param	row			Tile row.
	 * @param	solid		If the tile should be solid.
	 </haxe_doc>
		</setTile>
		<clearTile public="1" get="inline" set="null" line="92">
			<f a="?column:?row">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Makes the tile non-solid.
	 * @param	column		Tile column.
	 * @param	row			Tile row.
	 </haxe_doc>
		</clearTile>
		<checkTile get="inline" set="null" line="97"><f a="column:row">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></checkTile>
		<getTile public="1" set="method" line="117">
			<f a="?column:?row">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Gets the value of a tile.
	 * @param	column		Tile column.
	 * @param	row			Tile row.
	 * @return	tile value.
	 </haxe_doc>
		</getTile>
		<setRect public="1" set="method" line="137">
			<f a="?column:?row:?width:?height:?solid">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the value of a rectangle region of tiles.
	 * @param	column		First column.
	 * @param	row			First row.
	 * @param	width		Columns to fill.
	 * @param	height		Rows to fill.
	 * @param	fill		Value to fill.
	 </haxe_doc>
		</setRect>
		<clearRect public="1" get="inline" set="null" line="163">
			<f a="?column:?row:?width:?height">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Makes the rectangular region of tiles non-solid.
	 * @param	column		First column.
	 * @param	row			First row.
	 * @param	width		Columns to fill.
	 * @param	height		Rows to fill.
	 </haxe_doc>
		</clearRect>
		<loadFromString public="1" set="method" line="174">
			<f a="str:?columnSep:?rowSep">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Loads the grid data from a string.
	* @param str			The string data, which is a set of tile values (0 or 1) separated by the columnSep and rowSep strings.
	* @param columnSep		The string that separates each tile value on a row, default is ",".
	* @param rowSep			The string that separates each row of tiles, default is "\n".
	</haxe_doc>
		</loadFromString>
		<saveToString public="1" set="method" line="197">
			<f a="?columnSep:?rowSep">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	* Saves the grid data to a string.
	* @param columnSep		The string that separates each tile value on a row, default is ",".
	* @param rowSep			The string that separates each row of tiles, default is "\n".
	</haxe_doc>
		</saveToString>
		<tileWidth public="1" get="getTileWidth" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The tile width.
	 </haxe_doc>
		</tileWidth>
		<getTileWidth get="inline" set="null" line="217"><f a=""><c path="Int"/></f></getTileWidth>
		<tileHeight public="1" get="getTileHeight" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The tile height.
	 </haxe_doc>
		</tileHeight>
		<getTileHeight get="inline" set="null" line="223"><f a=""><c path="Int"/></f></getTileHeight>
		<columns public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * How many columns the grid has
	 </haxe_doc>
		</columns>
		<rows public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * How many rows the grid has.
	 </haxe_doc>
		</rows>
		<data public="1" set="null">
			<c path="Array"><c path="Array"><e path="Bool"/></c></c>
			<haxe_doc>
	 * The grid data.
	 </haxe_doc>
		</data>
		<collideMask set="method" line="241" override="1">
			<f a="other">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against an Entity. </haxe_doc>
		</collideMask>
		<collideHitbox set="method" line="265" override="1">
			<f a="other">
				<c path="com.haxepunk.masks.Hitbox"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against a Hitbox. </haxe_doc>
		</collideHitbox>
		<collidePixelmask set="method" line="289">
			<f a="other">
				<c path="com.haxepunk.masks.Pixelmask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collides against a Pixelmask. </haxe_doc>
		</collidePixelmask>
		<debugDraw public="1" set="method" line="337" override="1"><f a="graphics:scaleX:scaleY">
	<c path="flash.display.Graphics"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></debugDraw>
		<squareProjection public="1" set="method" line="379"><f a="axis:point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></squareProjection>
		<_tile><c path="flash.geom.Rectangle"/></_tile>
		<_rect><c path="flash.geom.Rectangle"/></_rect>
		<_point><c path="flash.geom.Point"/></_point>
		<_point2><c path="flash.geom.Point"/></_point2>
		<new public="1" set="method" line="32">
			<f a="width:height:tileWidth:tileHeight:?x:?y">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	width			Width of the grid, in pixels.
	 * @param	height			Height of the grid, in pixels.
	 * @param	tileWidth		Width of a grid tile, in pixels.
	 * @param	tileHeight		Height of a grid tile, in pixels.
	 * @param	x				X offset of the grid.
	 * @param	y				Y offset of the grid.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Uses a hash grid to determine collision, faster than
 * using hundreds of Entities for tiled levels, etc.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.Masklist" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/Masklist.hx">
		<extends path="com.haxepunk.masks.Hitbox"/>
		<collide public="1" set="method" line="27" override="1">
			<f a="mask">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collide against a mask. </haxe_doc>
		</collide>
		<collideMasklist set="method" line="38" override="1">
			<f a="other">
				<c path="com.haxepunk.masks.Masklist"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collide against a Masklist. </haxe_doc>
		</collideMasklist>
		<add public="1" set="method" line="57">
			<f a="mask">
				<c path="com.haxepunk.Mask"/>
				<c path="com.haxepunk.Mask"/>
			</f>
			<haxe_doc>
	 * Adds a Mask to the list.
	 * @param	mask		The Mask to add.
	 * @return	The added Mask.
	 </haxe_doc>
		</add>
		<remove public="1" set="method" line="71">
			<f a="mask">
				<c path="com.haxepunk.Mask"/>
				<c path="com.haxepunk.Mask"/>
			</f>
			<haxe_doc>
	 * Removes the Mask from the list.
	 * @param	mask		The Mask to remove.
	 * @return	The removed Mask.
	 </haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="97">
			<f a="?index">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes the Mask at the index.
	 * @param	index		The Mask index.
	 </haxe_doc>
		</removeAt>
		<removeAll public="1" set="method" line="120">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes all Masks from the list.
	 </haxe_doc>
		</removeAll>
		<getMask public="1" set="method" line="135">
			<f a="?index">
				<c path="Int"/>
				<c path="com.haxepunk.Mask"/>
			</f>
			<haxe_doc>
	 * Gets a Mask from the list.
	 * @param	index		The Mask index.
	 * @return	The Mask at the index.
	 </haxe_doc>
		</getMask>
		<assignTo public="1" set="method" line="140" override="1"><f a="parent">
	<c path="com.haxepunk.Entity"/>
	<e path="Void"/>
</f></assignTo>
		<update public="1" set="method" line="147" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates the parent's bounds for this mask. </haxe_doc>
		</update>
		<count public="1" get="getCount" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Amount of Masks in the list.
	 </haxe_doc>
		</count>
		<getCount set="method" line="174"><f a=""><c path="Int"/></f></getCount>
		<_masks><c path="Array"><c path="com.haxepunk.Mask"/></c></_masks>
		<_temp><c path="Array"><c path="com.haxepunk.Mask"/></c></_temp>
		<_count><c path="Int"/></_count>
		<new public="1" set="method" line="16">
			<f a="masks">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	...mask		Masks to add to the list.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A Mask that can contain multiple Masks of one or various types.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.Pixelmask" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/Pixelmask.hx">
		<extends path="com.haxepunk.masks.Hitbox"/>
		<threshold public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Alpha threshold of the bitmap used for collision.
	 </haxe_doc>
		</threshold>
		<collideMask set="method" line="53" override="1">
			<f a="other">
				<c path="com.haxepunk.Mask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collide against an Entity. </haxe_doc>
		</collideMask>
		<collideHitbox set="method" line="69" override="1">
			<f a="other">
				<c path="com.haxepunk.masks.Hitbox"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collide against a Hitbox. </haxe_doc>
		</collideHitbox>
		<collidePixelmask set="method" line="85">
			<f a="other">
				<c path="com.haxepunk.masks.Pixelmask"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> @private Collide against a Pixelmask. </haxe_doc>
		</collidePixelmask>
		<data public="1" get="getData" set="setData">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>
	 * Current BitmapData mask.
	 </haxe_doc>
		</data>
		<getData set="method" line="102"><f a=""><c path="flash.display.BitmapData"/></f></getData>
		<setData set="method" line="103"><f a="value">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></setData>
		<_data><c path="flash.display.BitmapData"/></_data>
		<_rect><c path="flash.geom.Rectangle"/></_rect>
		<_point><c path="flash.geom.Point"/></_point>
		<_point2><c path="flash.geom.Point"/></_point2>
		<new public="1" set="method" line="25">
			<f a="source:?x:?y">
				<d/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	source		The image to use as a mask.
	 * @param	x			X offset of the mask.
	 * @param	y			Y offset of the mask.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A bitmap mask used for pixel-perfect collision. 
 </haxe_doc>
	</class>
	<class path="com.haxepunk.masks.Polygon" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/masks/Polygon.hx">
		<extends path="com.haxepunk.Mask"/>
		<createPolygon public="1" set="method" line="530" static="1">
			<f a="?sides:?radius:?angle">
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.haxepunk.masks.Polygon"/>
			</f>
			<haxe_doc>
	 * Creates a polygon with even sides
	 * @param	sides	The number of sides in the polygon
	 * @param	radius	The distance that the corners are at
	 * @param	angle	How much the polygon is rotated
	 * @return	The polygon
	 </haxe_doc>
		</createPolygon>
		<createFromArray public="1" set="method" line="558" static="1">
			<f a="points">
				<c path="Array"><c path="Float"/></c>
				<c path="com.haxepunk.masks.Polygon"/>
			</f>
			<haxe_doc>
	 * Creates a polygon from an array were even numbers are x and odd are y
	 * @param	points
	 </haxe_doc>
		</createFromArray>
		<_axis line="575" static="1"><c path="flash.geom.Point"/></_axis>
		<firstCollisionInfo line="576" static="1"><c path="com.haxepunk.masks.CollisionInfo"/></firstCollisionInfo>
		<secondCollisionInfo line="577" static="1"><c path="com.haxepunk.masks.CollisionInfo"/></secondCollisionInfo>
		<vertical public="1" line="579" static="1"><c path="flash.geom.Point"/></vertical>
		<horizontal public="1" line="580" static="1"><c path="flash.geom.Point"/></horizontal>
		<centerPoint public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * The polygon rotates around this point when the angle is set.
	 </haxe_doc>
		</centerPoint>
		<generateAxes set="method" line="39"><f a=""><e path="Void"/></f></generateAxes>
		<removeDuplicateAxes set="method" line="70"><f a=""><e path="Void"/></f></removeDuplicateAxes>
		<collideGrid public="1" set="method" line="95">
			<f a="grid">
				<c path="com.haxepunk.masks.Grid"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * May be very slow, mainly added for completeness sake
	 * Checks for collisions along the edges of the polygon
	 * @param	grid
	 * @return
	 </haxe_doc>
		</collideGrid>
		<collideCircle public="1" set="method" line="198"><f a="circle">
	<c path="com.haxepunk.masks.Circle"/>
	<e path="Bool"/>
</f></collideCircle>
		<collideHitbox public="1" set="method" line="257"><f a="hitbox">
	<c path="com.haxepunk.masks.Hitbox"/>
	<e path="Bool"/>
</f></collideHitbox>
		<collideMask set="method" line="302" override="1"><f a="other">
	<c path="com.haxepunk.Mask"/>
	<e path="Bool"/>
</f></collideMask>
		<collidePolygon public="1" set="method" line="347"><f a="other">
	<c path="com.haxepunk.masks.Polygon"/>
	<e path="Bool"/>
</f></collidePolygon>
		<dot get="inline" set="null" line="389">
			<f a="p1:p2">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Calculates the dotProduct between two points
	 </haxe_doc>
		</dot>
		<projectOn public="1" get="inline" set="null" line="394"><f a="axis:collisionInfo">
	<c path="flash.geom.Point"/>
	<c path="com.haxepunk.masks.CollisionInfo"/>
	<e path="Void"/>
</f></projectOn>
		<rotate set="method" line="417"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<angle public="1" get="getAngle" set="setAngle">
			<c path="Float"/>
			<haxe_doc>
	 * Angle in degress that the polygon is rotated.
	 </haxe_doc>
		</angle>
		<getAngle get="inline" set="null" line="464"><f a=""><c path="Float"/></f></getAngle>
		<setAngle set="method" line="465"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setAngle>
		<width public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Width.
	 </haxe_doc>
		</width>
		<height public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Height.
	 </haxe_doc>
		</height>
		<points public="1" get="getPoints" set="setPoints">
			<c path="Array"><c path="flash.geom.Point"/></c>
			<haxe_doc><![CDATA[
	 * The points representing the polygon.
	 * If you need to set a point yourself instead of passing in a new Array<Point> you need to call update() to makes sure the axes update as well.
	 ]]></haxe_doc>
		</points>
		<getPoints get="inline" set="null" line="489"><f a=""><c path="Array"><c path="flash.geom.Point"/></c></f></getPoints>
		<setPoints set="method" line="490"><f a="value">
	<c path="Array"><c path="flash.geom.Point"/></c>
	<c path="Array"><c path="flash.geom.Point"/></c>
</f></setPoints>
		<update public="1" set="method" line="501" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc> Updates the parent's bounds for this mask. </haxe_doc>
		</update>
		<updateAxes public="1" get="inline" set="null" line="517"><f a=""><e path="Void"/></f></updateAxes>
		<_angle><c path="Float"/></_angle>
		<_points><c path="Array"><c path="flash.geom.Point"/></c></_points>
		<_axes><c path="Array"><c path="flash.geom.Point"/></c></_axes>
		<new public="1" set="method" line="23">
			<f a="points:?centerPoint">
				<c path="Array"><c path="flash.geom.Point"/></c>
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	radius		Radius of the circle.
	 * @param	x			X offset of the circle.
	 * @param	y			Y offset of the circle.
	 </haxe_doc>
		</new>
	</class>
	<class path="com.haxepunk.tweens.misc.MultiVarTween" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/tweens/misc/MultiVarTween.hx">
		<extends path="com.haxepunk.Tween"/>
		<tween public="1" set="method" line="32">
			<f a="object:values:duration:?ease">
				<d/>
				<d/>
				<c path="Float"/>
				<t path="com.haxepunk.utils.EaseFunction"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Tweens multiple numeric public properties.
	 * @param	object		The object containing the properties.
	 * @param	values		An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.
	 * @param	ease		Optional easer function.
	 </haxe_doc>
		</tween>
		<update public="1" set="method" line="55" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc> @private Updates the Tween. </haxe_doc>
		</update>
		<_object><d/></_object>
		<_vars><c path="Array"><c path="String"/></c></_vars>
		<_start><c path="Array"><c path="Float"/></c></_start>
		<_range><c path="Array"><c path="Float"/></c></_range>
		<new public="1" set="method" line="16">
			<f a="?complete:?type">
				<t path="com.haxepunk.CompleteCallback"/>
				<e path="com.haxepunk.TweenType"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * @param	complete		Optional completion callback.
	 * @param	type			Tween type.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Tweens multiple numeric public properties of an Object simultaneously.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.utils.Draw" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/utils/Draw.hx">
		<blend public="1" static="1">
			<e path="flash.display.BlendMode"/>
			<haxe_doc>
	 * The blending mode used by Draw functions. This will not
	 * apply to Draw.line(), but will apply to Draw.linePlus().
	 </haxe_doc>
		</blend>
		<setTarget public="1" set="method" line="34" static="1">
			<f a="target:?camera:?blend">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<e path="flash.display.BlendMode"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the drawing target for Draw functions.
	 * @param	target		The buffer to draw to.
	 * @param	camera		The camera offset (use null for none).
	 * @param	blend		The blend mode to use.
	 </haxe_doc>
		</setTarget>
		<resetTarget public="1" set="method" line="44" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resets the drawing target to the default. The same as calling Draw.setTarget(HXP.buffer, HXP.camera).
	 </haxe_doc>
		</resetTarget>
		<drawToScreen get="inline" set="null" line="51" static="1"><f a=""><e path="Void"/></f></drawToScreen>
		<line public="1" set="method" line="69" static="1">
			<f a="x1:y1:x2:y2:?color">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a pixelated, non-antialiased line.
	 * @param	x1		Starting x position.
	 * @param	y1		Starting y position.
	 * @param	x2		Ending x position.
	 * @param	y2		Ending y position.
	 * @param	color	Color of the line.
	 </haxe_doc>
		</line>
		<linePlus public="1" set="method" line="169" static="1">
			<f a="x1:y1:x2:y2:?color:?alpha:?thick">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a smooth, antialiased line with optional alpha and thickness.
	 * @param	x1		Starting x position.
	 * @param	y1		Starting y position.
	 * @param	x2		Ending x position.
	 * @param	y2		Ending y position.
	 * @param	color	Color of the line.
	 * @param	alpha	Alpha of the line.
	 * @param	thick	The thickness of the line.
	 </haxe_doc>
		</linePlus>
		<rect public="1" set="method" line="187" static="1">
			<f a="x:y:width:height:?color:?alpha">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a filled rectangle.
	 * @param	x			X position of the rectangle.
	 * @param	y			Y position of the rectangle.
	 * @param	width		Width of the rectangle.
	 * @param	height		Height of the rectangle.
	 * @param	color		Color of the rectangle.
	 * @param	alpha		Alpha of the rectangle.
	 </haxe_doc>
		</rect>
		<circle public="1" set="method" line="213" static="1">
			<f a="x:y:radius:?color">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a non-filled, pixelated circle.
	 * @param	x			Center x position.
	 * @param	y			Center y position.
	 * @param	radius		Radius of the circle.
	 * @param	color		Color of the circle.
	 </haxe_doc>
		</circle>
		<circlePlus public="1" set="method" line="259" static="1">
			<f a="x:y:radius:?color:?alpha:?fill:?thick">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a circle to the screen.
	 * @param	x			X position of the circle's center.
	 * @param	y			Y position of the circle's center.
	 * @param	radius		Radius of the circle.
	 * @param	color		Color of the circle.
	 * @param	alpha		Alpha of the circle.
	 * @param	fill		If the circle should be filled with the color (true) or just an outline (false).
	 * @param	thick		How thick the outline should be (only applicable when fill = false).
	 </haxe_doc>
		</circlePlus>
		<hitbox public="1" set="method" line="283" static="1">
			<f a="e:?outline:?color:?alpha">
				<c path="com.haxepunk.Entity"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws the Entity's hitbox.
	 * @param	e			The Entity whose hitbox is to be drawn.
	 * @param	outline		If just the hitbox's outline should be drawn.
	 * @param	color		Color of the hitbox.
	 * @param	alpha		Alpha of the hitbox.
	 </haxe_doc>
		</hitbox>
		<curve public="1" set="method" line="333" static="1">
			<f a="x1:y1:x2:y2:x3:y3:?thick:?color:?alpha">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a quadratic curve.
	 * @param	x1		X start.
	 * @param	y1		Y start.
	 * @param	x2		X control point, used to determine the curve.
	 * @param	y2		Y control point, used to determine the curve.
	 * @param	x3		X finish.
	 * @param	y3		Y finish.
	 * @param	color	Color of the curve
	 * @param	alpha	Alpha transparency.
	 </haxe_doc>
		</curve>
		<graphic public="1" set="method" line="348" static="1">
			<f a="g:?x:?y">
				<c path="com.haxepunk.Graphic"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a graphic object.
	 * @param	g		The Graphic to draw.
	 * @param	x		X position.
	 * @param	y		Y position.
	 </haxe_doc>
		</graphic>
		<entity public="1" set="method" line="371" static="1">
			<f a="e:?x:?y:?addEntityPosition">
				<c path="com.haxepunk.Entity"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws an Entity object.
	 * @param	e					The Entity to draw.
	 * @param	x					X position.
	 * @param	y					Y position.
	 * @param	addEntityPosition	Adds the Entity's x and y position to the target position.
	 </haxe_doc>
		</entity>
		<text public="1" set="method" line="387" static="1">
			<f a="text:?x:?y:?options">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<t path="com.haxepunk.graphics.TextOptions"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws text.
	 * @param  text    The text to render.
	 * @param  x       X position.
	 * @param  y       Y position.
	 * @param  options Options (see Text constructor).
	 </haxe_doc>
		</text>
		<_target static="1"><c path="flash.display.BitmapData"/></_target>
		<_camera static="1"><c path="flash.geom.Point"/></_camera>
		<_graphics line="396" static="1"><c path="flash.display.Graphics"/></_graphics>
		<_rect line="397" static="1"><c path="flash.geom.Rectangle"/></_rect>
		<_matrix line="398" static="1"><c path="flash.geom.Matrix"/></_matrix>
		<haxe_doc>
 * Static class with access to miscellanious drawing functions.
 * These functions are not meant to replace Graphic components
 * for Entities, but rather to help with testing and debugging.
 </haxe_doc>
	</class>
	<typedef path="com.haxepunk.utils.EaseFunction" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/utils/Ease.hx" module="com.haxepunk.utils.Ease"><f a="">
	<c path="Float"/>
	<c path="Float"/>
</f></typedef>
	<class path="com.haxepunk.utils.Ease" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/utils/Ease.hx">
		<quadIn public="1" set="method" line="11" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quadratic in. </haxe_doc>
		</quadIn>
		<quadOut public="1" set="method" line="17" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quadratic out. </haxe_doc>
		</quadOut>
		<quadInOut public="1" set="method" line="23" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quadratic in and out. </haxe_doc>
		</quadInOut>
		<cubeIn public="1" set="method" line="29" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Cubic in. </haxe_doc>
		</cubeIn>
		<cubeOut public="1" set="method" line="35" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Cubic out. </haxe_doc>
		</cubeOut>
		<cubeInOut public="1" set="method" line="41" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Cubic in and out. </haxe_doc>
		</cubeInOut>
		<quartIn public="1" set="method" line="47" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quart in. </haxe_doc>
		</quartIn>
		<quartOut public="1" set="method" line="53" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quart out. </haxe_doc>
		</quartOut>
		<quartInOut public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quart in and out. </haxe_doc>
		</quartInOut>
		<quintIn public="1" set="method" line="65" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quint in. </haxe_doc>
		</quintIn>
		<quintOut public="1" set="method" line="71" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quint out. </haxe_doc>
		</quintOut>
		<quintInOut public="1" set="method" line="77" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Quint in and out. </haxe_doc>
		</quintInOut>
		<sineIn public="1" set="method" line="83" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Sine in. </haxe_doc>
		</sineIn>
		<sineOut public="1" set="method" line="89" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Sine out. </haxe_doc>
		</sineOut>
		<sineInOut public="1" set="method" line="95" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Sine in and out. </haxe_doc>
		</sineInOut>
		<bounceIn public="1" set="method" line="101" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Bounce in. </haxe_doc>
		</bounceIn>
		<bounceOut public="1" set="method" line="111" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Bounce out. </haxe_doc>
		</bounceOut>
		<bounceInOut public="1" set="method" line="120" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Bounce in and out. </haxe_doc>
		</bounceInOut>
		<circIn public="1" set="method" line="138" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Circle in. </haxe_doc>
		</circIn>
		<circOut public="1" set="method" line="144" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Circle out. </haxe_doc>
		</circOut>
		<circInOut public="1" set="method" line="150" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Circle in and out. </haxe_doc>
		</circInOut>
		<expoIn public="1" set="method" line="156" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Exponential in. </haxe_doc>
		</expoIn>
		<expoOut public="1" set="method" line="162" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Exponential out. </haxe_doc>
		</expoOut>
		<expoInOut public="1" set="method" line="168" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Exponential in and out. </haxe_doc>
		</expoInOut>
		<backIn public="1" set="method" line="174" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Back in. </haxe_doc>
		</backIn>
		<backOut public="1" set="method" line="180" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Back out. </haxe_doc>
		</backOut>
		<backInOut public="1" set="method" line="186" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc> Back in and out. </haxe_doc>
		</backInOut>
		<PI get="inline" set="null" line="195" static="1"><c path="Float"/></PI>
		<PI2 get="inline" set="null" line="196" static="1"><c path="Float"/></PI2>
		<EL get="inline" set="null" line="197" static="1"><c path="Float"/></EL>
		<B1 get="inline" set="null" line="198" static="1"><c path="Float"/></B1>
		<B2 get="inline" set="null" line="199" static="1"><c path="Float"/></B2>
		<B3 get="inline" set="null" line="200" static="1"><c path="Float"/></B3>
		<B4 get="inline" set="null" line="201" static="1"><c path="Float"/></B4>
		<B5 get="inline" set="null" line="202" static="1"><c path="Float"/></B5>
		<B6 get="inline" set="null" line="203" static="1"><c path="Float"/></B6>
		<haxe_doc>
 * Static class with useful easer functions that can be used by Tweens.
 </haxe_doc>
	</class>
	<class path="com.haxepunk.utils.Input" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/utils/Input.hx">
		<keyString public="1" line="14" static="1"><c path="String"/></keyString>
		<deadZone public="1" line="15" static="1"><c path="Float"/></deadZone>
		<lastKey public="1" static="1"><c path="Int"/></lastKey>
		<mouseDown public="1" static="1"><e path="Bool"/></mouseDown>
		<mouseUp public="1" static="1"><e path="Bool"/></mouseUp>
		<mousePressed public="1" static="1"><e path="Bool"/></mousePressed>
		<mouseReleased public="1" static="1"><e path="Bool"/></mouseReleased>
		<mouseWheel public="1" static="1"><e path="Bool"/></mouseWheel>
		<mouseX public="1" get="getMouseX" set="null" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * X position of the mouse on the screen.
	 </haxe_doc>
		</mouseX>
		<getMouseX set="method" line="29" static="1"><f a=""><c path="Int"/></f></getMouseX>
		<mouseY public="1" get="getMouseY" set="null" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Y position of the mouse on the screen.
	 </haxe_doc>
		</mouseY>
		<getMouseY set="method" line="38" static="1"><f a=""><c path="Int"/></f></getMouseY>
		<mouseFlashX public="1" get="getMouseFlashX" set="null" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * The absolute mouse x position on the screen (unscaled).
	 </haxe_doc>
		</mouseFlashX>
		<getMouseFlashX set="method" line="47" static="1"><f a=""><c path="Int"/></f></getMouseFlashX>
		<mouseFlashY public="1" get="getMouseFlashY" set="null" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * The absolute mouse y position on the screen (unscaled).
	 </haxe_doc>
		</mouseFlashY>
		<getMouseFlashY set="method" line="56" static="1"><f a=""><c path="Int"/></f></getMouseFlashY>
		<define public="1" set="method" line="66" static="1">
			<f a="name:keys">
				<c path="String"/>
				<c path="Array"><c path="Int"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Defines a new input.
	 * @param	name		String to map the input to.
	 * @param	keys		The keys to use for the Input.
	 </haxe_doc>
		</define>
		<check public="1" set="method" line="76" static="1">
			<f a="input">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * If the input or key is held down.
	 * @param	input		An input name or key to check for.
	 * @return	True or false.
	 </haxe_doc>
		</check>
		<pressed public="1" set="method" line="101" static="1">
			<f a="input">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * If the input or key was pressed this frame.
	 * @param	input		An input name or key to check for.
	 * @return	True or false.
	 </haxe_doc>
		</pressed>
		<released public="1" set="method" line="121" static="1">
			<f a="input">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * If the input or key was released this frame.
	 * @param	input		An input name or key to check for.
	 * @return	True or false.
	 </haxe_doc>
		</released>
		<indexOf set="method" line="142" static="1">
			<f a="a:v">
				<c path="Array"><c path="Int"/></c>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Copy of Lambda.indexOf for speed/memory reasons
	 * @param	a array to use
	 * @param	v value to find index of
	 * @return	index of value in the array
	 </haxe_doc>
		</indexOf>
		<joystick public="1" set="method" line="153" static="1"><f a="id">
	<c path="Int"/>
	<c path="com.haxepunk.utils.Joystick"/>
</f></joystick>
		<enable public="1" set="method" line="164" static="1"><f a=""><e path="Void"/></f></enable>
		<update public="1" set="method" line="184" static="1"><f a=""><e path="Void"/></f></update>
		<onKeyDown set="method" line="194" static="1"><f a="?e">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<onKeyUp set="method" line="218" static="1"><f a="?e">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyUp>
		<onMouseDown set="method" line="229" static="1"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseDown>
		<onMouseUp set="method" line="239" static="1"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<onMouseWheel set="method" line="246" static="1"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseWheel>
		<kKeyStringMax get="inline" set="null" line="301" static="1"><c path="Int"/></kKeyStringMax>
		<_enabled line="303" static="1"><e path="Bool"/></_enabled>
		<_joysticks line="304" static="1"><c path="IntHash"><c path="com.haxepunk.utils.Joystick"/></c></_joysticks>
		<_key line="305" static="1"><c path="Array"><e path="Bool"/></c></_key>
		<_keyNum line="306" static="1"><c path="Int"/></_keyNum>
		<_press line="307" static="1"><c path="Array"><c path="Int"/></c></_press>
		<_pressNum line="308" static="1"><c path="Int"/></_pressNum>
		<_release line="309" static="1"><c path="Array"><c path="Int"/></c></_release>
		<_releaseNum line="310" static="1"><c path="Int"/></_releaseNum>
		<_control line="311" static="1"><c path="Hash"><c path="Array"><c path="Int"/></c></c></_control>
		<_mouseWheelDelta line="312" static="1"><c path="Int"/></_mouseWheelDelta>
	</class>
	<class path="com.haxepunk.utils.Joystick" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/utils/Joystick.hx">
		<buttons public="1"><c path="Array"><e path="Bool"/></c></buttons>
		<axis public="1"><c path="flash.geom.Point"/></axis>
		<hat public="1"><c path="flash.geom.Point"/></hat>
		<ball public="1"><c path="flash.geom.Point"/></ball>
		<connected public="1"><e path="Bool"/></connected>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.haxepunk.utils.Key" params="" file="/usr/lib/haxe/lib/HaxePunk/1,6,4/com/haxepunk/utils/Key.hx">
		<ANY public="1" get="inline" set="null" line="5" static="1"><c path="Int"/></ANY>
		<LEFT public="1" get="inline" set="null" line="7" static="1"><c path="Int"/></LEFT>
		<UP public="1" get="inline" set="null" line="8" static="1"><c path="Int"/></UP>
		<RIGHT public="1" get="inline" set="null" line="9" static="1"><c path="Int"/></RIGHT>
		<DOWN public="1" get="inline" set="null" line="10" static="1"><c path="Int"/></DOWN>
		<ENTER public="1" get="inline" set="null" line="12" static="1"><c path="Int"/></ENTER>
		<COMMAND public="1" get="inline" set="null" line="13" static="1"><c path="Int"/></COMMAND>
		<CONTROL public="1" get="inline" set="null" line="14" static="1"><c path="Int"/></CONTROL>
		<SPACE public="1" get="inline" set="null" line="15" static="1"><c path="Int"/></SPACE>
		<SHIFT public="1" get="inline" set="null" line="16" static="1"><c path="Int"/></SHIFT>
		<BACKSPACE public="1" get="inline" set="null" line="17" static="1"><c path="Int"/></BACKSPACE>
		<CAPS_LOCK public="1" get="inline" set="null" line="18" static="1"><c path="Int"/></CAPS_LOCK>
		<DELETE public="1" get="inline" set="null" line="19" static="1"><c path="Int"/></DELETE>
		<END public="1" get="inline" set="null" line="20" static="1"><c path="Int"/></END>
		<ESCAPE public="1" get="inline" set="null" line="21" static="1"><c path="Int"/></ESCAPE>
		<HOME public="1" get="inline" set="null" line="22" static="1"><c path="Int"/></HOME>
		<INSERT public="1" get="inline" set="null" line="23" static="1"><c path="Int"/></INSERT>
		<TAB public="1" get="inline" set="null" line="24" static="1"><c path="Int"/></TAB>
		<PAGE_DOWN public="1" get="inline" set="null" line="25" static="1"><c path="Int"/></PAGE_DOWN>
		<PAGE_UP public="1" get="inline" set="null" line="26" static="1"><c path="Int"/></PAGE_UP>
		<LEFT_SQUARE_BRACKET public="1" get="inline" set="null" line="27" static="1"><c path="Int"/></LEFT_SQUARE_BRACKET>
		<RIGHT_SQUARE_BRACKET public="1" get="inline" set="null" line="28" static="1"><c path="Int"/></RIGHT_SQUARE_BRACKET>
		<A public="1" get="inline" set="null" line="31" static="1"><c path="Int"/></A>
		<B public="1" get="inline" set="null" line="32" static="1"><c path="Int"/></B>
		<C public="1" get="inline" set="null" line="33" static="1"><c path="Int"/></C>
		<D public="1" get="inline" set="null" line="34" static="1"><c path="Int"/></D>
		<E public="1" get="inline" set="null" line="35" static="1"><c path="Int"/></E>
		<F public="1" get="inline" set="null" line="36" static="1"><c path="Int"/></F>
		<G public="1" get="inline" set="null" line="37" static="1"><c path="Int"/></G>
		<H public="1" get="inline" set="null" line="38" static="1"><c path="Int"/></H>
		<I public="1" get="inline" set="null" line="39" static="1"><c path="Int"/></I>
		<J public="1" get="inline" set="null" line="40" static="1"><c path="Int"/></J>
		<K public="1" get="inline" set="null" line="41" static="1"><c path="Int"/></K>
		<L public="1" get="inline" set="null" line="42" static="1"><c path="Int"/></L>
		<M public="1" get="inline" set="null" line="43" static="1"><c path="Int"/></M>
		<N public="1" get="inline" set="null" line="44" static="1"><c path="Int"/></N>
		<O public="1" get="inline" set="null" line="45" static="1"><c path="Int"/></O>
		<P public="1" get="inline" set="null" line="46" static="1"><c path="Int"/></P>
		<Q public="1" get="inline" set="null" line="47" static="1"><c path="Int"/></Q>
		<R public="1" get="inline" set="null" line="48" static="1"><c path="Int"/></R>
		<S public="1" get="inline" set="null" line="49" static="1"><c path="Int"/></S>
		<T public="1" get="inline" set="null" line="50" static="1"><c path="Int"/></T>
		<U public="1" get="inline" set="null" line="51" static="1"><c path="Int"/></U>
		<V public="1" get="inline" set="null" line="52" static="1"><c path="Int"/></V>
		<W public="1" get="inline" set="null" line="53" static="1"><c path="Int"/></W>
		<X public="1" get="inline" set="null" line="54" static="1"><c path="Int"/></X>
		<Y public="1" get="inline" set="null" line="55" static="1"><c path="Int"/></Y>
		<Z public="1" get="inline" set="null" line="56" static="1"><c path="Int"/></Z>
		<F1 public="1" get="inline" set="null" line="87" static="1"><c path="Int"/></F1>
		<F2 public="1" get="inline" set="null" line="88" static="1"><c path="Int"/></F2>
		<F3 public="1" get="inline" set="null" line="89" static="1"><c path="Int"/></F3>
		<F4 public="1" get="inline" set="null" line="90" static="1"><c path="Int"/></F4>
		<F5 public="1" get="inline" set="null" line="91" static="1"><c path="Int"/></F5>
		<F6 public="1" get="inline" set="null" line="92" static="1"><c path="Int"/></F6>
		<F7 public="1" get="inline" set="null" line="93" static="1"><c path="Int"/></F7>
		<F8 public="1" get="inline" set="null" line="94" static="1"><c path="Int"/></F8>
		<F9 public="1" get="inline" set="null" line="95" static="1"><c path="Int"/></F9>
		<F10 public="1" get="inline" set="null" line="96" static="1"><c path="Int"/></F10>
		<F11 public="1" get="inline" set="null" line="97" static="1"><c path="Int"/></F11>
		<F12 public="1" get="inline" set="null" line="98" static="1"><c path="Int"/></F12>
		<F13 public="1" get="inline" set="null" line="99" static="1"><c path="Int"/></F13>
		<F14 public="1" get="inline" set="null" line="100" static="1"><c path="Int"/></F14>
		<F15 public="1" get="inline" set="null" line="101" static="1"><c path="Int"/></F15>
		<DIGIT_0 public="1" get="inline" set="null" line="103" static="1"><c path="Int"/></DIGIT_0>
		<DIGIT_1 public="1" get="inline" set="null" line="104" static="1"><c path="Int"/></DIGIT_1>
		<DIGIT_2 public="1" get="inline" set="null" line="105" static="1"><c path="Int"/></DIGIT_2>
		<DIGIT_3 public="1" get="inline" set="null" line="106" static="1"><c path="Int"/></DIGIT_3>
		<DIGIT_4 public="1" get="inline" set="null" line="107" static="1"><c path="Int"/></DIGIT_4>
		<DIGIT_5 public="1" get="inline" set="null" line="108" static="1"><c path="Int"/></DIGIT_5>
		<DIGIT_6 public="1" get="inline" set="null" line="109" static="1"><c path="Int"/></DIGIT_6>
		<DIGIT_7 public="1" get="inline" set="null" line="110" static="1"><c path="Int"/></DIGIT_7>
		<DIGIT_8 public="1" get="inline" set="null" line="111" static="1"><c path="Int"/></DIGIT_8>
		<DIGIT_9 public="1" get="inline" set="null" line="112" static="1"><c path="Int"/></DIGIT_9>
		<NUMPAD_0 public="1" get="inline" set="null" line="114" static="1"><c path="Int"/></NUMPAD_0>
		<NUMPAD_1 public="1" get="inline" set="null" line="115" static="1"><c path="Int"/></NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" line="116" static="1"><c path="Int"/></NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" line="117" static="1"><c path="Int"/></NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" line="118" static="1"><c path="Int"/></NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" line="119" static="1"><c path="Int"/></NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" line="120" static="1"><c path="Int"/></NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" line="121" static="1"><c path="Int"/></NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" line="122" static="1"><c path="Int"/></NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" line="123" static="1"><c path="Int"/></NUMPAD_9>
		<NUMPAD_ADD public="1" get="inline" set="null" line="124" static="1"><c path="Int"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" line="125" static="1"><c path="Int"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" line="126" static="1"><c path="Int"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" get="inline" set="null" line="127" static="1"><c path="Int"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" line="128" static="1"><c path="Int"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" get="inline" set="null" line="129" static="1"><c path="Int"/></NUMPAD_SUBTRACT>
		<nameOfKey public="1" set="method" line="136" static="1">
			<f a="char">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Returns the name of the key.
	 * @param	char		The key to name.
	 * @return	The name.
	 </haxe_doc>
		</nameOfKey>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<currentFrameLabel public="1" set="null"><c path="String"/></currentFrameLabel>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><e path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<isPlaying public="1"><e path="Bool"/></isPlaying>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="53" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="85" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="94" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="104" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="112" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="118" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="146" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="161" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="205" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<start set="method" line="55"><f a=""><e path="Void"/></f></start>
		<doInitDelay set="method" line="76"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<init set="method" line="81"><f a=""><e path="Void"/></f></init>
		<new public="1" set="method" line="47"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<length public="1"><t path="UInt"/></length>
		<fixed public="1"><e path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Vector class is very similar to Array but is only supported by the Flash Player 10+
</haxe_doc>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><t path="UInt"/></errno>
		<stub public="1"><e path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><e path="Bool"/></silent>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><c path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<width public="1" set="null"><c path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<drawWithQuality public="1"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="flash.display.StageQuality"/>
	<e path="Void"/>
</f></drawWithQuality>
		<encode public="1"><f a="rect:compressor:?byteArray">
	<c path="flash.geom.Rectangle"/>
	<d/>
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
</f></encode>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><t path="UInt"/></c>
</f></getVector>
		<histogram public="1" set="method"><f a="?hRect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
</f></histogram>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setVector public="1" set="method"><f a="rect:inputVector">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><t path="UInt"/></c>
	<e path="Void"/>
</f></setVector>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" set="null"><c path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/std/flash/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginShaderFill public="1" set="method"><f a="shader:?matrix">
	<c path="flash.display.Shader"/>
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></beginShaderFill>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<copyFrom public="1" set="method"><f a="sourceGraphics">
	<c path="flash.display.Graphics"/>
	<e path="Void"/>
</f></copyFrom>
		<cubicCurveTo public="1"><f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></cubicCurveTo>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method"><f a="graphicsData">
	<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
	<e path="Void"/>
</f></drawGraphicsData>
		<drawPath public="1" set="method"><f a="commands:data:?winding">
	<c path="flash.Vector"><c path="Int"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="flash.display.GraphicsPathWinding"/>
	<e path="Void"/>
</f></drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method"><f a="vertices:?indices:?uvtData:?culling">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Int"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="flash.display.TriangleCulling"/>
	<e path="Void"/>
</f></drawTriangles>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></lineBitmapStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineShaderStyle public="1" set="method"><f a="shader:?matrix">
	<c path="flash.display.Shader"/>
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></lineShaderStyle>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<uncaughtErrorEvents public="1"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<unloadAndStop public="1" set="method"><f a="?gc">
	<e path="Bool"/>
	<e path="Void"/>
</f></unloadAndStop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<height public="1" set="null"><c path="Int"/></height>
		<isURLInaccessible public="1"><e path="Bool"/></isURLInaccessible>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<uncaughtErrorEvents public="1"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><c path="Int"/></width>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<allowsFullScreen public="1"><e path="Bool"/></allowsFullScreen>
		<allowsFullScreenInteractive public="1"><e path="Bool"/></allowsFullScreenInteractive>
		<color public="1"><t path="UInt"/></color>
		<colorCorrection public="1"><e path="flash.display.ColorCorrection"/></colorCorrection>
		<colorCorrectionSupport public="1" set="null"><e path="flash.display.ColorCorrectionSupport"/></colorCorrectionSupport>
		<displayContextInfo public="1"><c path="String"/></displayContextInfo>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><c path="Float"/></frameRate>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<mouseLock public="1"><e path="Bool"/></mouseLock>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<softKeyboardRect public="1"><c path="flash.geom.Rectangle"/></softKeyboardRect>
		<stage3Ds public="1"><c path="flash.Vector"><c path="flash.display.Stage3D"/></c></stage3Ds>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageVideos public="1"><c path="flash.Vector"><c path="flash.media.StageVideo"/></c></stageVideos>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<wmodeGPU public="1"><e path="Bool"/></wmodeGPU>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<visible public="1"><e path="Bool"/></visible>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createRectangleTexture public="1"><f a="width:height:format:optimizeForRenderToTexture">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="flash.display3D.textures.RectangleTexture"/>
</f></createRectangleTexture>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setProgramConstantsFromByteArray public="1"><f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setProgramConstantsFromByteArray>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector:?colorOutputIndex">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/RectangleTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.errors.TypeError" params="" file="/usr/lib/haxe/std/flash/errors/TypeError.hx" extern="1"><extends path="flash.errors.Error"/></class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1"><c path="String"/></CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<COPY public="1" static="1"><c path="String"/></COPY>
		<CUT public="1" static="1"><c path="String"/></CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1"><c path="String"/></EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1"><c path="String"/></FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1"><c path="String"/></FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1"><c path="String"/></PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1"><c path="String"/></SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1"><c path="String"/></SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1"><c path="String"/></TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
	</enum>
	<class path="flash.events.KeyboardEvent" params="" file="/usr/lib/haxe/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><e path="Bool"/></altKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/lib/haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1"><c path="String"/></CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1"><c path="String"/></MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1"><c path="String"/></MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1"><c path="String"/></MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1"><c path="String"/></RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1"><c path="String"/></RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1"><c path="String"/></RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1"><c path="String"/></RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<altKey public="1"><e path="Bool"/></altKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<delta public="1"><c path="Int"/></delta>
		<isRelatedObjectInaccessible public="1"><e path="Bool"/></isRelatedObjectInaccessible>
		<localX public="1"><c path="Float"/></localX>
		<localY public="1"><c path="Float"/></localY>
		<movementX public="1"><c path="Float"/></movementX>
		<movementY public="1"><c path="Float"/></movementY>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<color public="1"><t path="UInt"/></color>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<redOffset public="1"><c path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1"><f a="sourceMatrix3D">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></copyFrom>
		<copyRawDataFrom public="1"><f a="vector:?index:?transpose">
	<c path="flash.Vector"><c path="Float"/></c>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyRawDataFrom>
		<copyRawDataTo public="1"><f a="vector:?index:?transpose">
	<c path="flash.Vector"><c path="Float"/></c>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyRawDataTo>
		<copyRowFrom public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowTo>
		<copyToMatrix3D public="1"><f a="dest">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></copyToMatrix3D>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<focalLength public="1"><c path="Float"/></focalLength>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<matrix3D public="1"><c path="flash.geom.Matrix3D"/></matrix3D>
		<perspectiveProjection public="1"><c path="flash.geom.PerspectiveProjection"/></perspectiveProjection>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<getRelativeMatrix3D public="1" set="method"><f a="relativeTo">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Matrix3D"/>
</f></getRelativeMatrix3D>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<length public="1" set="null"><c path="Float"/></length>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<w public="1"><c path="Float"/></w>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<z public="1"><c path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1"><f a="sourceVector3D">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyFrom>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<setTo public="1"><f a="xa:ya:za">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1"><f a=""><e path="Void"/></f></_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<fps public="1" set="null"><c path="Float"/></fps>
		<height public="1" set="null"><c path="Int"/></height>
		<index public="1" set="null"><c path="Int"/></index>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<position public="1"><c path="String"/></position>
		<quality public="1" set="null"><c path="Int"/></quality>
		<width public="1" set="null"><c path="Int"/></width>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.media.ID3Info" params="" file="/usr/lib/haxe/std/flash/media/ID3Info.hx" extern="1">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<codec public="1"><e path="flash.media.SoundCodec"/></codec>
		<enableVAD public="1"><e path="Bool"/></enableVAD>
		<encodeQuality public="1"><c path="Int"/></encodeQuality>
		<enhancedOptions public="1"><c path="flash.media.MicrophoneEnhancedOptions"/></enhancedOptions>
		<framesPerPacket public="1"><c path="Int"/></framesPerPacket>
		<gain public="1"><c path="Float"/></gain>
		<index public="1" set="null"><c path="Int"/></index>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<noiseSuppressionLevel public="1"><c path="Int"/></noiseSuppressionLevel>
		<rate public="1"><c path="Int"/></rate>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<autoGain public="1"><e path="Bool"/></autoGain>
		<echoPath public="1"><c path="Int"/></echoPath>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.media.Sound" params="" file="/usr/lib/haxe/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<isURLInaccessible public="1"><e path="Bool"/></isURLInaccessible>
		<length public="1" set="null"><c path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<extract public="1" set="method"><f a="target:length:?startPosition">
	<c path="flash.utils.ByteArray"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></extract>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1"><f a="bytes:bytesLength">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1"><f a="bytes:samples:?format:?stereo:?sampleRate">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Float"/>
	<e path="Void"/>
</f></loadPCMFromByteArray>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/usr/lib/haxe/std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="/usr/lib/haxe/std/flash/media/SoundLoaderContext.hx" extern="1">
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundMixer" params="" file="/usr/lib/haxe/std/flash/media/SoundMixer.hx" extern="1">
		<audioPlaybackMode public="1" static="1"><c path="String"/></audioPlaybackMode>
		<bufferTime public="1" static="1"><c path="Int"/></bufferTime>
		<soundTransform public="1" static="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useSpeakerphoneForVoice public="1" static="1"><e path="Bool"/></useSpeakerphoneForVoice>
		<areSoundsInaccessible public="1" set="method" static="1"><f a=""><e path="Bool"/></f></areSoundsInaccessible>
		<computeSpectrum public="1" set="method" static="1"><f a="outputArray:?FFTMode:?stretchFactor">
	<c path="flash.utils.ByteArray"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></computeSpectrum>
		<stopAll public="1" set="method" static="1"><f a=""><e path="Void"/></f></stopAll>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<depth public="1"><c path="Int"/></depth>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<codec public="1" set="null"><c path="String"/></codec>
		<fps public="1" set="null"><c path="Float"/></fps>
		<height public="1" set="null"><c path="Int"/></height>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<quality public="1" set="null"><c path="Int"/></quality>
		<width public="1" set="null"><c path="Int"/></width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<farID public="1" set="null"><c path="String"/></farID>
		<farNonce public="1" set="null"><c path="String"/></farNonce>
		<maxPeerConnections public="1"><t path="UInt"/></maxPeerConnections>
		<nearID public="1" set="null"><c path="String"/></nearID>
		<nearNonce public="1" set="null"><c path="String"/></nearNonce>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<protocol public="1" set="null"><c path="String"/></protocol>
		<proxyType public="1"><c path="String"/></proxyType>
		<unconnectedPeerStreams public="1" set="null"><c path="Array"><d/></c></unconnectedPeerStreams>
		<uri public="1" set="null"><c path="String"/></uri>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1"><c path="String"/></CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1"><c path="String"/></DIRECT_CONNECTIONS>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<audioReliable public="1"><e path="Bool"/></audioReliable>
		<audioSampleAccess public="1"><e path="Bool"/></audioSampleAccess>
		<backBufferLength public="1"><c path="Float"/></backBufferLength>
		<backBufferTime public="1"><c path="Float"/></backBufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferTimeMax public="1"><c path="Float"/></bufferTimeMax>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<client public="1"><d/></client>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<dataReliable public="1"><e path="Bool"/></dataReliable>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<farID public="1" set="null"><c path="String"/></farID>
		<farNonce public="1" set="null"><c path="String"/></farNonce>
		<inBufferSeek public="1"><e path="Bool"/></inBufferSeek>
		<info public="1" set="null"><c path="flash.net.NetStreamInfo"/></info>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<maxPauseBufferTime public="1"><c path="Float"/></maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1"><e path="Bool"/></multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1"><c path="Float"/></multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1"><c path="Float"/></multicastFetchPeriod>
		<multicastInfo public="1"><c path="flash.net.NetStreamMulticastInfo"/></multicastInfo>
		<multicastPushNeighborLimit public="1"><c path="Float"/></multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1"><c path="Float"/></multicastRelayMarginDuration>
		<multicastWindowDuration public="1"><c path="Float"/></multicastWindowDuration>
		<nearNonce public="1" set="null"><c path="String"/></nearNonce>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<peerStreams public="1" set="null"><c path="Array"><d/></c></peerStreams>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<time public="1" set="null"><c path="Float"/></time>
		<useHardwareDecoder public="1"><e path="Bool"/></useHardwareDecoder>
		<useJitterBuffer public="1"><e path="Bool"/></useJitterBuffer>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<videoReliable public="1"><e path="Bool"/></videoReliable>
		<videoSampleAccess public="1"><e path="Bool"/></videoSampleAccess>
		<videoStreamSettings public="1"><c path="flash.media.VideoStreamSettings"/></videoStreamSettings>
		<appendBytes public="1"><f a="bytes">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></appendBytes>
		<appendBytesAction public="1"><f a="netStreamAppendBytesAction">
	<c path="String"/>
	<e path="Void"/>
</f></appendBytesAction>
		<attach public="1"><f a="connection">
	<c path="flash.net.NetConnection"/>
	<e path="Void"/>
</f></attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<dispose public="1"><f a=""><e path="Void"/></f></dispose>
		<onPeerConnect public="1" set="method"><f a="subscriber">
	<c path="flash.net.NetStream"/>
	<e path="Bool"/>
</f></onPeerConnect>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<play2 public="1" set="method"><f a="param">
	<c path="flash.net.NetStreamPlayOptions"/>
	<e path="Void"/>
</f></play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<step public="1"><f a="frames">
	<c path="Int"/>
	<e path="Void"/>
</f></step>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<uri public="1" set="null"><c path="String"/></uri>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoLossRate public="1"><c path="Float"/></videoLossRate>
		<xmpData public="1" set="null"><d/></xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><c path="Float"/></len>
		<offset public="1"><c path="Float"/></offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><c path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1"><c path="String"/></digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1"><t path="UInt"/></MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<domainMemory public="1"><c path="flash.utils.ByteArray"/></domainMemory>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<getQualifiedDefinitionNames public="1"><f a=""><c path="flash.Vector"><c path="String"/></c></f></getQualifiedDefinitionNames>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.IME" params="" file="/usr/lib/haxe/std/flash/system/IME.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<conversionMode public="1" static="1"><e path="flash.system.IMEConversionMode"/></conversionMode>
		<enabled public="1" static="1"><e path="Bool"/></enabled>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<compositionAbandoned public="1" static="1"><f a=""><e path="Void"/></f></compositionAbandoned>
		<compositionSelectionChanged public="1" static="1"><f a="start:end">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></compositionSelectionChanged>
		<doConversion public="1" set="method" static="1"><f a=""><e path="Void"/></f></doConversion>
		<setCompositionString public="1" set="method" static="1"><f a="composition">
	<c path="String"/>
	<e path="Void"/>
</f></setCompositionString>
	</class>
	<enum path="flash.system.IMEConversionMode" params="" file="/usr/lib/haxe/std/flash/system/IMEConversionMode.hx">
		<UNKNOWN/>
		<KOREAN/>
		<JAPANESE_KATAKANA_HALF/>
		<JAPANESE_KATAKANA_FULL/>
		<JAPANESE_HIRAGANA/>
		<CHINESE/>
		<ALPHANUMERIC_HALF/>
		<ALPHANUMERIC_FULL/>
	</enum>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1"><e path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><e path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<imageDecodingPolicy public="1"><e path="flash.system.ImageDecodingPolicy"/></imageDecodingPolicy>
		<parameters public="1"><d/></parameters>
		<requestedContentParent public="1"><c path="flash.display.DisplayObjectContainer"/></requestedContentParent>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1"><c path="String"/></domainID>
	</class>
	<class path="flash.system.System" params="" file="/usr/lib/haxe/std/flash/system/System.hx" extern="1">
		<freeMemory public="1" static="1"><c path="Float"/></freeMemory>
		<ime public="1" set="null" static="1"><c path="flash.system.IME"/></ime>
		<privateMemory public="1" static="1"><c path="Float"/></privateMemory>
		<processCPUUsage public="1" static="1"><c path="Float"/></processCPUUsage>
		<totalMemory public="1" set="null" static="1"><t path="UInt"/></totalMemory>
		<totalMemoryNumber public="1" static="1"><c path="Float"/></totalMemoryNumber>
		<useCodePage public="1" static="1"><e path="Bool"/></useCodePage>
		<vmVersion public="1" set="null" static="1"><c path="String"/></vmVersion>
		<disposeXML public="1" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="Void"/>
</f></disposeXML>
		<exit public="1" set="method" static="1"><f a="code">
	<t path="UInt"/>
	<e path="Void"/>
</f></exit>
		<gc public="1" set="method" static="1"><f a=""><e path="Void"/></f></gc>
		<pause public="1" set="method" static="1"><f a=""><e path="Void"/></f></pause>
		<pauseForGCIfCollectionImminent public="1" static="1"><f a="?imminence">
	<c path="Float"/>
	<e path="Void"/>
</f></pauseForGCIfCollectionImminent>
		<resume public="1" set="method" static="1"><f a=""><e path="Void"/></f></resume>
		<setClipboard public="1" set="method" static="1"><f a="string">
	<c path="String"/>
	<e path="Void"/>
</f></setClipboard>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
	</enum>
	<class path="flash.text.Font" params="" file="/usr/lib/haxe/std/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.FontStyle" params="" file="/usr/lib/haxe/std/flash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
	</enum>
	<enum path="flash.text.FontType" params="" file="/usr/lib/haxe/std/flash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1"><f a="fontName:fontStyle">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></isFontCompatible>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><e path="Bool"/></background>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<border public="1"><e path="Bool"/></border>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><c path="Int"/></length>
		<maxChars public="1"><c path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><e path="Bool"/></multiline>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><c path="Int"/></scrollH>
		<scrollV public="1"><c path="Int"/></scrollV>
		<selectable public="1"><e path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<sharpness public="1"><c path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><t path="UInt"/></textColor>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textInteractionMode public="1"><e path="flash.text.TextInteractionMode"/></textInteractionMode>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<thickness public="1"><c path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><c path="Float"/></ascent>
		<descent public="1"><c path="Float"/></descent>
		<height public="1"><c path="Float"/></height>
		<leading public="1"><c path="Float"/></leading>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<clipboardItems public="1"><c path="flash.ui.ContextMenuClipboardItems"/></clipboardItems>
		<clipboardMenu public="1"><e path="Bool"/></clipboardMenu>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<link public="1"><c path="flash.net.URLRequest"/></link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<loop public="1"><e path="Bool"/></loop>
		<play public="1"><e path="Bool"/></play>
		<print public="1"><e path="Bool"/></print>
		<quality public="1"><e path="Bool"/></quality>
		<rewind public="1"><e path="Bool"/></rewind>
		<save public="1"><e path="Bool"/></save>
		<zoom public="1"><e path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clear public="1"><e path="Bool"/></clear>
		<copy public="1"><e path="Bool"/></copy>
		<cut public="1"><e path="Bool"/></cut>
		<paste public="1"><e path="Bool"/></paste>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="/usr/lib/haxe/std/flash/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
	</enum>
	<class path="flash.ui.Keyboard" params="" file="/usr/lib/haxe/std/flash/ui/Keyboard.hx" extern="1">
		<A public="1" static="1"><t path="UInt"/></A>
		<ALTERNATE public="1" static="1"><t path="UInt"/></ALTERNATE>
		<AUDIO public="1" static="1"><t path="UInt"/></AUDIO>
		<B public="1" static="1"><t path="UInt"/></B>
		<BACK public="1" static="1"><t path="UInt"/></BACK>
		<BACKQUOTE public="1" static="1"><t path="UInt"/></BACKQUOTE>
		<BACKSLASH public="1" static="1"><t path="UInt"/></BACKSLASH>
		<BACKSPACE public="1" static="1"><t path="UInt"/></BACKSPACE>
		<BLUE public="1" static="1"><t path="UInt"/></BLUE>
		<C public="1" static="1"><t path="UInt"/></C>
		<CAPS_LOCK public="1" static="1"><t path="UInt"/></CAPS_LOCK>
		<CHANNEL_DOWN public="1" static="1"><t path="UInt"/></CHANNEL_DOWN>
		<CHANNEL_UP public="1" static="1"><t path="UInt"/></CHANNEL_UP>
		<COMMA public="1" static="1"><t path="UInt"/></COMMA>
		<COMMAND public="1" static="1"><t path="UInt"/></COMMAND>
		<CONTROL public="1" static="1"><t path="UInt"/></CONTROL>
		<CharCodeStrings public="1" static="1"><c path="Array"><d/></c></CharCodeStrings>
		<D public="1" static="1"><t path="UInt"/></D>
		<DELETE public="1" static="1"><t path="UInt"/></DELETE>
		<DOWN public="1" static="1"><t path="UInt"/></DOWN>
		<DVR public="1" static="1"><t path="UInt"/></DVR>
		<E public="1" static="1"><t path="UInt"/></E>
		<END public="1" static="1"><t path="UInt"/></END>
		<ENTER public="1" static="1"><t path="UInt"/></ENTER>
		<EQUAL public="1" static="1"><t path="UInt"/></EQUAL>
		<ESCAPE public="1" static="1"><t path="UInt"/></ESCAPE>
		<EXIT public="1" static="1"><t path="UInt"/></EXIT>
		<F public="1" static="1"><t path="UInt"/></F>
		<F1 public="1" static="1"><t path="UInt"/></F1>
		<F10 public="1" static="1"><t path="UInt"/></F10>
		<F11 public="1" static="1"><t path="UInt"/></F11>
		<F12 public="1" static="1"><t path="UInt"/></F12>
		<F13 public="1" static="1"><t path="UInt"/></F13>
		<F14 public="1" static="1"><t path="UInt"/></F14>
		<F15 public="1" static="1"><t path="UInt"/></F15>
		<F2 public="1" static="1"><t path="UInt"/></F2>
		<F3 public="1" static="1"><t path="UInt"/></F3>
		<F4 public="1" static="1"><t path="UInt"/></F4>
		<F5 public="1" static="1"><t path="UInt"/></F5>
		<F6 public="1" static="1"><t path="UInt"/></F6>
		<F7 public="1" static="1"><t path="UInt"/></F7>
		<F8 public="1" static="1"><t path="UInt"/></F8>
		<F9 public="1" static="1"><t path="UInt"/></F9>
		<FAST_FORWARD public="1" static="1"><t path="UInt"/></FAST_FORWARD>
		<G public="1" static="1"><t path="UInt"/></G>
		<GREEN public="1" static="1"><t path="UInt"/></GREEN>
		<GUIDE public="1" static="1"><t path="UInt"/></GUIDE>
		<H public="1" static="1"><t path="UInt"/></H>
		<HELP public="1" static="1"><t path="UInt"/></HELP>
		<HOME public="1" static="1"><t path="UInt"/></HOME>
		<I public="1" static="1"><t path="UInt"/></I>
		<INFO public="1" static="1"><t path="UInt"/></INFO>
		<INPUT public="1" static="1"><t path="UInt"/></INPUT>
		<INSERT public="1" static="1"><t path="UInt"/></INSERT>
		<J public="1" static="1"><t path="UInt"/></J>
		<K public="1" static="1"><t path="UInt"/></K>
		<KEYNAME_BEGIN public="1" static="1"><c path="String"/></KEYNAME_BEGIN>
		<KEYNAME_BREAK public="1" static="1"><c path="String"/></KEYNAME_BREAK>
		<KEYNAME_CLEARDISPLAY public="1" static="1"><c path="String"/></KEYNAME_CLEARDISPLAY>
		<KEYNAME_CLEARLINE public="1" static="1"><c path="String"/></KEYNAME_CLEARLINE>
		<KEYNAME_DELETE public="1" static="1"><c path="String"/></KEYNAME_DELETE>
		<KEYNAME_DELETECHAR public="1" static="1"><c path="String"/></KEYNAME_DELETECHAR>
		<KEYNAME_DELETELINE public="1" static="1"><c path="String"/></KEYNAME_DELETELINE>
		<KEYNAME_DOWNARROW public="1" static="1"><c path="String"/></KEYNAME_DOWNARROW>
		<KEYNAME_END public="1" static="1"><c path="String"/></KEYNAME_END>
		<KEYNAME_EXECUTE public="1" static="1"><c path="String"/></KEYNAME_EXECUTE>
		<KEYNAME_F1 public="1" static="1"><c path="String"/></KEYNAME_F1>
		<KEYNAME_F10 public="1" static="1"><c path="String"/></KEYNAME_F10>
		<KEYNAME_F11 public="1" static="1"><c path="String"/></KEYNAME_F11>
		<KEYNAME_F12 public="1" static="1"><c path="String"/></KEYNAME_F12>
		<KEYNAME_F13 public="1" static="1"><c path="String"/></KEYNAME_F13>
		<KEYNAME_F14 public="1" static="1"><c path="String"/></KEYNAME_F14>
		<KEYNAME_F15 public="1" static="1"><c path="String"/></KEYNAME_F15>
		<KEYNAME_F16 public="1" static="1"><c path="String"/></KEYNAME_F16>
		<KEYNAME_F17 public="1" static="1"><c path="String"/></KEYNAME_F17>
		<KEYNAME_F18 public="1" static="1"><c path="String"/></KEYNAME_F18>
		<KEYNAME_F19 public="1" static="1"><c path="String"/></KEYNAME_F19>
		<KEYNAME_F2 public="1" static="1"><c path="String"/></KEYNAME_F2>
		<KEYNAME_F20 public="1" static="1"><c path="String"/></KEYNAME_F20>
		<KEYNAME_F21 public="1" static="1"><c path="String"/></KEYNAME_F21>
		<KEYNAME_F22 public="1" static="1"><c path="String"/></KEYNAME_F22>
		<KEYNAME_F23 public="1" static="1"><c path="String"/></KEYNAME_F23>
		<KEYNAME_F24 public="1" static="1"><c path="String"/></KEYNAME_F24>
		<KEYNAME_F25 public="1" static="1"><c path="String"/></KEYNAME_F25>
		<KEYNAME_F26 public="1" static="1"><c path="String"/></KEYNAME_F26>
		<KEYNAME_F27 public="1" static="1"><c path="String"/></KEYNAME_F27>
		<KEYNAME_F28 public="1" static="1"><c path="String"/></KEYNAME_F28>
		<KEYNAME_F29 public="1" static="1"><c path="String"/></KEYNAME_F29>
		<KEYNAME_F3 public="1" static="1"><c path="String"/></KEYNAME_F3>
		<KEYNAME_F30 public="1" static="1"><c path="String"/></KEYNAME_F30>
		<KEYNAME_F31 public="1" static="1"><c path="String"/></KEYNAME_F31>
		<KEYNAME_F32 public="1" static="1"><c path="String"/></KEYNAME_F32>
		<KEYNAME_F33 public="1" static="1"><c path="String"/></KEYNAME_F33>
		<KEYNAME_F34 public="1" static="1"><c path="String"/></KEYNAME_F34>
		<KEYNAME_F35 public="1" static="1"><c path="String"/></KEYNAME_F35>
		<KEYNAME_F4 public="1" static="1"><c path="String"/></KEYNAME_F4>
		<KEYNAME_F5 public="1" static="1"><c path="String"/></KEYNAME_F5>
		<KEYNAME_F6 public="1" static="1"><c path="String"/></KEYNAME_F6>
		<KEYNAME_F7 public="1" static="1"><c path="String"/></KEYNAME_F7>
		<KEYNAME_F8 public="1" static="1"><c path="String"/></KEYNAME_F8>
		<KEYNAME_F9 public="1" static="1"><c path="String"/></KEYNAME_F9>
		<KEYNAME_FIND public="1" static="1"><c path="String"/></KEYNAME_FIND>
		<KEYNAME_HELP public="1" static="1"><c path="String"/></KEYNAME_HELP>
		<KEYNAME_HOME public="1" static="1"><c path="String"/></KEYNAME_HOME>
		<KEYNAME_INSERT public="1" static="1"><c path="String"/></KEYNAME_INSERT>
		<KEYNAME_INSERTCHAR public="1" static="1"><c path="String"/></KEYNAME_INSERTCHAR>
		<KEYNAME_INSERTLINE public="1" static="1"><c path="String"/></KEYNAME_INSERTLINE>
		<KEYNAME_LEFTARROW public="1" static="1"><c path="String"/></KEYNAME_LEFTARROW>
		<KEYNAME_MENU public="1" static="1"><c path="String"/></KEYNAME_MENU>
		<KEYNAME_MODESWITCH public="1" static="1"><c path="String"/></KEYNAME_MODESWITCH>
		<KEYNAME_NEXT public="1" static="1"><c path="String"/></KEYNAME_NEXT>
		<KEYNAME_PAGEDOWN public="1" static="1"><c path="String"/></KEYNAME_PAGEDOWN>
		<KEYNAME_PAGEUP public="1" static="1"><c path="String"/></KEYNAME_PAGEUP>
		<KEYNAME_PAUSE public="1" static="1"><c path="String"/></KEYNAME_PAUSE>
		<KEYNAME_PREV public="1" static="1"><c path="String"/></KEYNAME_PREV>
		<KEYNAME_PRINT public="1" static="1"><c path="String"/></KEYNAME_PRINT>
		<KEYNAME_PRINTSCREEN public="1" static="1"><c path="String"/></KEYNAME_PRINTSCREEN>
		<KEYNAME_REDO public="1" static="1"><c path="String"/></KEYNAME_REDO>
		<KEYNAME_RESET public="1" static="1"><c path="String"/></KEYNAME_RESET>
		<KEYNAME_RIGHTARROW public="1" static="1"><c path="String"/></KEYNAME_RIGHTARROW>
		<KEYNAME_SCROLLLOCK public="1" static="1"><c path="String"/></KEYNAME_SCROLLLOCK>
		<KEYNAME_SELECT public="1" static="1"><c path="String"/></KEYNAME_SELECT>
		<KEYNAME_STOP public="1" static="1"><c path="String"/></KEYNAME_STOP>
		<KEYNAME_SYSREQ public="1" static="1"><c path="String"/></KEYNAME_SYSREQ>
		<KEYNAME_SYSTEM public="1" static="1"><c path="String"/></KEYNAME_SYSTEM>
		<KEYNAME_UNDO public="1" static="1"><c path="String"/></KEYNAME_UNDO>
		<KEYNAME_UPARROW public="1" static="1"><c path="String"/></KEYNAME_UPARROW>
		<KEYNAME_USER public="1" static="1"><c path="String"/></KEYNAME_USER>
		<L public="1" static="1"><t path="UInt"/></L>
		<LAST public="1" static="1"><t path="UInt"/></LAST>
		<LEFT public="1" static="1"><t path="UInt"/></LEFT>
		<LEFTBRACKET public="1" static="1"><t path="UInt"/></LEFTBRACKET>
		<LIVE public="1" static="1"><t path="UInt"/></LIVE>
		<M public="1" static="1"><t path="UInt"/></M>
		<MASTER_SHELL public="1" static="1"><t path="UInt"/></MASTER_SHELL>
		<MENU public="1" static="1"><t path="UInt"/></MENU>
		<MINUS public="1" static="1"><t path="UInt"/></MINUS>
		<N public="1" static="1"><t path="UInt"/></N>
		<NEXT public="1" static="1"><t path="UInt"/></NEXT>
		<NUMBER_0 public="1" static="1"><t path="UInt"/></NUMBER_0>
		<NUMBER_1 public="1" static="1"><t path="UInt"/></NUMBER_1>
		<NUMBER_2 public="1" static="1"><t path="UInt"/></NUMBER_2>
		<NUMBER_3 public="1" static="1"><t path="UInt"/></NUMBER_3>
		<NUMBER_4 public="1" static="1"><t path="UInt"/></NUMBER_4>
		<NUMBER_5 public="1" static="1"><t path="UInt"/></NUMBER_5>
		<NUMBER_6 public="1" static="1"><t path="UInt"/></NUMBER_6>
		<NUMBER_7 public="1" static="1"><t path="UInt"/></NUMBER_7>
		<NUMBER_8 public="1" static="1"><t path="UInt"/></NUMBER_8>
		<NUMBER_9 public="1" static="1"><t path="UInt"/></NUMBER_9>
		<NUMPAD public="1" static="1"><t path="UInt"/></NUMPAD>
		<NUMPAD_0 public="1" static="1"><t path="UInt"/></NUMPAD_0>
		<NUMPAD_1 public="1" static="1"><t path="UInt"/></NUMPAD_1>
		<NUMPAD_2 public="1" static="1"><t path="UInt"/></NUMPAD_2>
		<NUMPAD_3 public="1" static="1"><t path="UInt"/></NUMPAD_3>
		<NUMPAD_4 public="1" static="1"><t path="UInt"/></NUMPAD_4>
		<NUMPAD_5 public="1" static="1"><t path="UInt"/></NUMPAD_5>
		<NUMPAD_6 public="1" static="1"><t path="UInt"/></NUMPAD_6>
		<NUMPAD_7 public="1" static="1"><t path="UInt"/></NUMPAD_7>
		<NUMPAD_8 public="1" static="1"><t path="UInt"/></NUMPAD_8>
		<NUMPAD_9 public="1" static="1"><t path="UInt"/></NUMPAD_9>
		<NUMPAD_ADD public="1" static="1"><t path="UInt"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" static="1"><t path="UInt"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" static="1"><t path="UInt"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" static="1"><t path="UInt"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" static="1"><t path="UInt"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" static="1"><t path="UInt"/></NUMPAD_SUBTRACT>
		<O public="1" static="1"><t path="UInt"/></O>
		<P public="1" static="1"><t path="UInt"/></P>
		<PAGE_DOWN public="1" static="1"><t path="UInt"/></PAGE_DOWN>
		<PAGE_UP public="1" static="1"><t path="UInt"/></PAGE_UP>
		<PAUSE public="1" static="1"><t path="UInt"/></PAUSE>
		<PERIOD public="1" static="1"><t path="UInt"/></PERIOD>
		<PLAY public="1" static="1"><t path="UInt"/></PLAY>
		<PREVIOUS public="1" static="1"><t path="UInt"/></PREVIOUS>
		<Q public="1" static="1"><t path="UInt"/></Q>
		<QUOTE public="1" static="1"><t path="UInt"/></QUOTE>
		<R public="1" static="1"><t path="UInt"/></R>
		<RECORD public="1" static="1"><t path="UInt"/></RECORD>
		<RED public="1" static="1"><t path="UInt"/></RED>
		<REWIND public="1" static="1"><t path="UInt"/></REWIND>
		<RIGHT public="1" static="1"><t path="UInt"/></RIGHT>
		<RIGHTBRACKET public="1" static="1"><t path="UInt"/></RIGHTBRACKET>
		<S public="1" static="1"><t path="UInt"/></S>
		<SEARCH public="1" static="1"><t path="UInt"/></SEARCH>
		<SEMICOLON public="1" static="1"><t path="UInt"/></SEMICOLON>
		<SETUP public="1" static="1"><t path="UInt"/></SETUP>
		<SHIFT public="1" static="1"><t path="UInt"/></SHIFT>
		<SKIP_BACKWARD public="1" static="1"><t path="UInt"/></SKIP_BACKWARD>
		<SKIP_FORWARD public="1" static="1"><t path="UInt"/></SKIP_FORWARD>
		<SLASH public="1" static="1"><t path="UInt"/></SLASH>
		<SPACE public="1" static="1"><t path="UInt"/></SPACE>
		<STOP public="1" static="1"><t path="UInt"/></STOP>
		<STRING_BEGIN public="1" static="1"><c path="String"/></STRING_BEGIN>
		<STRING_BREAK public="1" static="1"><c path="String"/></STRING_BREAK>
		<STRING_CLEARDISPLAY public="1" static="1"><c path="String"/></STRING_CLEARDISPLAY>
		<STRING_CLEARLINE public="1" static="1"><c path="String"/></STRING_CLEARLINE>
		<STRING_DELETE public="1" static="1"><c path="String"/></STRING_DELETE>
		<STRING_DELETECHAR public="1" static="1"><c path="String"/></STRING_DELETECHAR>
		<STRING_DELETELINE public="1" static="1"><c path="String"/></STRING_DELETELINE>
		<STRING_DOWNARROW public="1" static="1"><c path="String"/></STRING_DOWNARROW>
		<STRING_END public="1" static="1"><c path="String"/></STRING_END>
		<STRING_EXECUTE public="1" static="1"><c path="String"/></STRING_EXECUTE>
		<STRING_F1 public="1" static="1"><c path="String"/></STRING_F1>
		<STRING_F10 public="1" static="1"><c path="String"/></STRING_F10>
		<STRING_F11 public="1" static="1"><c path="String"/></STRING_F11>
		<STRING_F12 public="1" static="1"><c path="String"/></STRING_F12>
		<STRING_F13 public="1" static="1"><c path="String"/></STRING_F13>
		<STRING_F14 public="1" static="1"><c path="String"/></STRING_F14>
		<STRING_F15 public="1" static="1"><c path="String"/></STRING_F15>
		<STRING_F16 public="1" static="1"><c path="String"/></STRING_F16>
		<STRING_F17 public="1" static="1"><c path="String"/></STRING_F17>
		<STRING_F18 public="1" static="1"><c path="String"/></STRING_F18>
		<STRING_F19 public="1" static="1"><c path="String"/></STRING_F19>
		<STRING_F2 public="1" static="1"><c path="String"/></STRING_F2>
		<STRING_F20 public="1" static="1"><c path="String"/></STRING_F20>
		<STRING_F21 public="1" static="1"><c path="String"/></STRING_F21>
		<STRING_F22 public="1" static="1"><c path="String"/></STRING_F22>
		<STRING_F23 public="1" static="1"><c path="String"/></STRING_F23>
		<STRING_F24 public="1" static="1"><c path="String"/></STRING_F24>
		<STRING_F25 public="1" static="1"><c path="String"/></STRING_F25>
		<STRING_F26 public="1" static="1"><c path="String"/></STRING_F26>
		<STRING_F27 public="1" static="1"><c path="String"/></STRING_F27>
		<STRING_F28 public="1" static="1"><c path="String"/></STRING_F28>
		<STRING_F29 public="1" static="1"><c path="String"/></STRING_F29>
		<STRING_F3 public="1" static="1"><c path="String"/></STRING_F3>
		<STRING_F30 public="1" static="1"><c path="String"/></STRING_F30>
		<STRING_F31 public="1" static="1"><c path="String"/></STRING_F31>
		<STRING_F32 public="1" static="1"><c path="String"/></STRING_F32>
		<STRING_F33 public="1" static="1"><c path="String"/></STRING_F33>
		<STRING_F34 public="1" static="1"><c path="String"/></STRING_F34>
		<STRING_F35 public="1" static="1"><c path="String"/></STRING_F35>
		<STRING_F4 public="1" static="1"><c path="String"/></STRING_F4>
		<STRING_F5 public="1" static="1"><c path="String"/></STRING_F5>
		<STRING_F6 public="1" static="1"><c path="String"/></STRING_F6>
		<STRING_F7 public="1" static="1"><c path="String"/></STRING_F7>
		<STRING_F8 public="1" static="1"><c path="String"/></STRING_F8>
		<STRING_F9 public="1" static="1"><c path="String"/></STRING_F9>
		<STRING_FIND public="1" static="1"><c path="String"/></STRING_FIND>
		<STRING_HELP public="1" static="1"><c path="String"/></STRING_HELP>
		<STRING_HOME public="1" static="1"><c path="String"/></STRING_HOME>
		<STRING_INSERT public="1" static="1"><c path="String"/></STRING_INSERT>
		<STRING_INSERTCHAR public="1" static="1"><c path="String"/></STRING_INSERTCHAR>
		<STRING_INSERTLINE public="1" static="1"><c path="String"/></STRING_INSERTLINE>
		<STRING_LEFTARROW public="1" static="1"><c path="String"/></STRING_LEFTARROW>
		<STRING_MENU public="1" static="1"><c path="String"/></STRING_MENU>
		<STRING_MODESWITCH public="1" static="1"><c path="String"/></STRING_MODESWITCH>
		<STRING_NEXT public="1" static="1"><c path="String"/></STRING_NEXT>
		<STRING_PAGEDOWN public="1" static="1"><c path="String"/></STRING_PAGEDOWN>
		<STRING_PAGEUP public="1" static="1"><c path="String"/></STRING_PAGEUP>
		<STRING_PAUSE public="1" static="1"><c path="String"/></STRING_PAUSE>
		<STRING_PREV public="1" static="1"><c path="String"/></STRING_PREV>
		<STRING_PRINT public="1" static="1"><c path="String"/></STRING_PRINT>
		<STRING_PRINTSCREEN public="1" static="1"><c path="String"/></STRING_PRINTSCREEN>
		<STRING_REDO public="1" static="1"><c path="String"/></STRING_REDO>
		<STRING_RESET public="1" static="1"><c path="String"/></STRING_RESET>
		<STRING_RIGHTARROW public="1" static="1"><c path="String"/></STRING_RIGHTARROW>
		<STRING_SCROLLLOCK public="1" static="1"><c path="String"/></STRING_SCROLLLOCK>
		<STRING_SELECT public="1" static="1"><c path="String"/></STRING_SELECT>
		<STRING_STOP public="1" static="1"><c path="String"/></STRING_STOP>
		<STRING_SYSREQ public="1" static="1"><c path="String"/></STRING_SYSREQ>
		<STRING_SYSTEM public="1" static="1"><c path="String"/></STRING_SYSTEM>
		<STRING_UNDO public="1" static="1"><c path="String"/></STRING_UNDO>
		<STRING_UPARROW public="1" static="1"><c path="String"/></STRING_UPARROW>
		<STRING_USER public="1" static="1"><c path="String"/></STRING_USER>
		<SUBTITLE public="1" static="1"><t path="UInt"/></SUBTITLE>
		<T public="1" static="1"><t path="UInt"/></T>
		<TAB public="1" static="1"><t path="UInt"/></TAB>
		<U public="1" static="1"><t path="UInt"/></U>
		<UP public="1" static="1"><t path="UInt"/></UP>
		<V public="1" static="1"><t path="UInt"/></V>
		<VOD public="1" static="1"><t path="UInt"/></VOD>
		<W public="1" static="1"><t path="UInt"/></W>
		<X public="1" static="1"><t path="UInt"/></X>
		<Y public="1" static="1"><t path="UInt"/></Y>
		<YELLOW public="1" static="1"><t path="UInt"/></YELLOW>
		<Z public="1" static="1"><t path="UInt"/></Z>
		<capsLock public="1" set="null" static="1"><e path="Bool"/></capsLock>
		<hasVirtualKeyboard public="1" static="1"><e path="Bool"/></hasVirtualKeyboard>
		<numLock public="1" set="null" static="1"><e path="Bool"/></numLock>
		<physicalKeyboardType public="1" static="1"><e path="flash.ui.KeyboardType"/></physicalKeyboardType>
		<isAccessible public="1" set="method" static="1"><f a=""><e path="Bool"/></f></isAccessible>
	</class>
	<enum path="flash.ui.KeyboardType" params="" file="/usr/lib/haxe/std/flash/ui/KeyboardType.hx">
		<NONE/>
		<KEYPAD/>
		<ALPHANUMERIC/>
	</enum>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><t path="UInt"/></length>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<position public="1"><t path="UInt"/></position>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<deflate public="1" set="method"><f a=""><e path="Void"/></f></deflate>
		<inflate public="1" set="method"><f a=""><e path="Void"/></f></inflate>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
	</enum>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<prefix public="1" set="null"><d/></prefix>
		<uri public="1" set="null"><c path="String"/></uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.utils.QName" params="" file="/usr/lib/haxe/std/flash/utils/QName.hx" extern="1">
		<localName public="1" set="null"><c path="String"/></localName>
		<uri public="1" set="null"><d/></uri>
		<new public="1" set="method"><f a="?namespace:?name">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.utils.RegExp" params="" file="/usr/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<global public="1" set="null"><e path="Bool"/></global>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<exec public="1" set="method"><f a="?s">
	<c path="String"/>
	<d/>
</f></exec>
		<test public="1" set="method"><f a="?s">
	<c path="String"/>
	<e path="Bool"/>
</f></test>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1"><f a="k">
	<c path="String"/>
	<d/>
</f></toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1"><f a="k">
	<c path="String"/>
	<d/>
</f></toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/lib/nme/3,3,2/haxe/Timer.hx">
		<delay public="1" set="method" line="56" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<measure public="1" params="T" set="method" line="67" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="77" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<stop public="1" set="method" line="32"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="53"><f a=""><e path="Void"/></f></run>
		<new public="1" set="method" line="18"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.xml._Fast.NodeAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="35"><f a="name">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</f></resolve>
		<new public="1" set="method" line="31"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.xml.Fast"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.AttribAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="54"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<new public="1" set="method" line="50"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasAttribAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="73"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="69"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasNodeAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="89"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="85"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.NodeListAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="103"><f a="name">
	<c path="String"/>
	<c path="List"><c path="haxe.xml.Fast"/></c>
</f></resolve>
		<new public="1" set="method" line="99"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="List"><c path="haxe.xml.Fast"/></c></haxe_dynamic>
	</class>
	<class path="haxe.xml.Fast" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx">
		<x public="1" set="null"><c path="Xml"/></x>
		<name public="1" get="getName" set="null"><c path="String"/></name>
		<innerData public="1" get="getInnerData" set="null"><c path="String"/></innerData>
		<innerHTML public="1" get="getInnerHTML" set="null"><c path="String"/></innerHTML>
		<node public="1" set="null"><c path="haxe.xml._Fast.NodeAccess"/></node>
		<nodes public="1" set="null"><c path="haxe.xml._Fast.NodeListAccess"/></nodes>
		<att public="1" set="null"><c path="haxe.xml._Fast.AttribAccess"/></att>
		<has public="1" set="null"><c path="haxe.xml._Fast.HasAttribAccess"/></has>
		<hasNode public="1" set="null"><c path="haxe.xml._Fast.HasNodeAccess"/></hasNode>
		<elements public="1" get="getElements" set="null"><t path="Iterator"><c path="haxe.xml.Fast"/></t></elements>
		<getName set="method" line="136"><f a=""><c path="String"/></f></getName>
		<getInnerData set="method" line="140"><f a=""><c path="String"/></f></getInnerData>
		<getInnerHTML set="method" line="160"><f a=""><c path="String"/></f></getInnerHTML>
		<getElements set="method" line="167"><f a=""><a>
	<next><f a=""><c path="haxe.xml.Fast"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></getElements>
		<new public="1" set="method" line="125"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="nme.Assets" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/Assets.hx">
		<cachedBitmapData public="1" line="18" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="28" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>
	 * Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache (Default: true)
	 * @return		A new BItmapData object
	 </haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="40" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>
	 * Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object
	 </haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="52" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>
	 * Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object
	 </haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="64" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>
	 * Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object
	 </haxe_doc>
		</getSound>
		<getText public="1" set="method" line="76" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object
	 </haxe_doc>
		</getText>
		<haxe_doc>
 * Provides a cross-platform interface for accessing embedded assets
 * @author Joshua Granick
 </haxe_doc>
	</class>
	<typedef path="nme.display.BitmapData" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.geom.Point" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<typedef path="nme.media.Sound" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/media/Sound.hx"><c path="flash.media.Sound"/></typedef>
	<typedef path="nme.text.Font" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/text/Font.hx"><c path="flash.text.Font"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="/usr/lib/haxe/lib/nme/3,3,2/nme/utils/ByteArray.hx"><c path="flash.utils.ByteArray"/></typedef>
</haxe>